---
layout:     post
title:      IOS面试集锦
subtitle:   面试-看这里就足够了-直通BAT
date:       2017-10-23
author:     JT
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 面试
---

# 1. 架构

## 1.1 架构

### 1.1.1 架构


# 2. 网络

## 2.1 网络

### 2.1.1 网络


# 3. 多线程

## 3.1 多线程

### 3.1.1 多线程

## 3.2 线程锁

### 3.2.1 什么是线程锁

线程锁:主要用来给方法、代码块加锁。当某个方法或者代码块使用锁时，那么在同一时刻至多仅有有一个线程在执行该段代码。当有多个线程访问同一对象的加锁方法/代码块时，同一时间只有一个线程在执行，其余线程必须要等待当前线程执行完之后才能执行该代码段。但是，其余线程是可以访问该对象中的非加锁代码块的。

### 3.2.2 线程锁种类

> NSLock

NSLock 遵循 NSLocking 协议，lock 方法是加锁，unlock 是解锁，tryLock 是尝试加锁,不会阻塞线程，如果失败的话返回 NO，lockBeforeDate: 是在指定Date之前尝试加锁,会阻塞线程，如果在指定时间之前都不能加锁，则返回NO。

```
    NSLock *lock = [[NSLock alloc] init];
    
    //线程1
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"线程1-1");
        [lock lock];
        NSLog(@"线程1-2");
        sleep(2);
        NSLog(@"线程1-3");
        [lock unlock];
        NSLog(@"线程1-4");
    });
    
    //线程2
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"线程2-1");
        sleep(1);//以保证让线程2的代码后执行
        NSLog(@"线程2-2");
        [lock lock];
        NSLog(@"线程2-3");
        [lock unlock];
        NSLog(@"线程2-4");
    });

    //线程3
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"线程3-1");
        sleep(1);//以保证让线程4的代码后执行
        NSLog(@"线程3-2");
        if ([lock tryLock]) {
            NSLog(@"线程3-3");
            [lock unlock];
        }
        else {
            NSLog(@"线程3加锁失败");
        }
    });
    
    //线程4
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"线程4-1");
        sleep(1);//以保证让线程4的代码后执行
        NSLog(@"线程4-2");
        if ([lock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:3]]) {
            NSLog(@"线程4-3");
            [lock unlock];
        }
        else {
            NSLog(@"线程4加锁失败");
        }
    });
```

某个线程A调用lock方法。这样，NSLock将被上锁。可以执行“关键部分”，完成后，调用unlock方法。

如果，在线程A 调用unlock方法之前，另一个线程B调用了同一锁对象的lock方法。那么，线程B只有等待。直到线程A调用了unlock。

> synchronized（互斥锁）

1. synchronized会创建一个异常捕获handler和一些内部的锁，所以使用@synchronized替换普通锁的代价是要付出更多的时间消耗
2. 创建给@synchronized指令的对象是一个用来区别保护块的唯一标识符。如果你在两个不同的线程里面执行上述方法，每次在一个线程传递了一个不同的对象给anObj参数，那么每次都将会拥有它的锁，并持续处理，中间不会被其他线程阻塞。然而如果你传递的是同一个对象，那么多个线程中的一个线程会首先获得该锁，而其他线程将会被阻塞直到第一个线程完成它的临界区
3. 作为一个预防措施。@synchronized块隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁，这就意味着为了使用@synchronized指令，你必须在你的代码中启用异常处理。如果你不想让隐式的异常处理例程带来额外的开销，那么可以使用其他的锁

> atomic

atomic只是给成员变量的set和get方法加了一个锁，防止多线程一直去读写这个成员变量。但这也仅仅是对读写的锁定，并不是线程安全。而且使用atomic比nonatomic慢了将近20倍

> dispatch_semaphore

```
dispatch_semaphore_create(long value);

dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);

dispatch_semaphore_signal(dispatch_semaphore_t dsema);
```

dispatch_semaphore 是 GCD 用来同步的一种方式，与他相关的只有三个函数，一个是创建信号量，一个是等待信号，一个是发送信号。

```
    dispatch_semaphore_t signal = dispatch_semaphore_create(1);
    dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC);
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        dispatch_semaphore_wait(signal, overTime);
        sleep(2);
        NSLog(@"线程1");
        dispatch_semaphore_signal(signal);
    });
    

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        sleep(1);
        dispatch_semaphore_wait(signal, overTime);
        NSLog(@"线程2");
        dispatch_semaphore_signal(signal);
    });
```

dispatch_semaphore 和 NSCondition 类似，都是一种基于信号的同步方式，但 NSCondition 信号只能发送，不能保存（如果没有线程在等待，则发送的信号会失效）。而 dispatch_semaphore 能保存发送的信号。dispatch_semaphore 的核心是 dispatch_semaphore_t 类型的信号量。

dispatch_semaphore_create(1) 方法可以创建一个 dispatch_semaphore_t 类型的信号量，设定信号量的初始值为 1。注意，这里的传入的参数必须大于或等于 0，否则 dispatch_semaphore_create 会返回 NULL。

dispatch_semaphore_wait(signal, overTime); 方法会判断 signal 的信号值是否大于 0。大于 0 不会阻塞线程，消耗掉一个信号，执行后续任务。如果信号值为 0，该线程会和 NSCondition 一样直接进入 waiting 状态，等待其他线程发送信号唤醒线程去执行后续任务，或者当 overTime  时限到了，也会执行后续任务。

dispatch_semaphore_signal(signal); 发送信号，如果没有等待的线程接受信号，则使 signal 信号值加一（做到对信号的保存）。

从上面的实例代码可以看到，一个 dispatch_semaphore_wait(signal, overTime); 方法会去对应一个 dispatch_semaphore_signal(signal); 看起来像 NSLock 的 lock 和 unlock，其实可以这样理解，区别只在于有信号量这个参数，lock unlock 只能同一时间，一个线程访问被保护的临界区，而如果 dispatch_semaphore 的信号量初始值为 x ，则可以有 x 个线程同时访问被保护的临界区。

> NSCondition

```
@interface NSCondition : NSObject <NSLocking> {

@private

    void *_priv;
}

- (void)wait;//挂起线程
- (BOOL)waitUntilDate:(NSDate *)limit;
- (void)signal; //任意通知一个线程
- (void)broadcast; //通知所有等待的线程

@property (nullable,copy) NSString *nameNS_AVAILABLE(10_5,2_0);

@end
```

类似GCD的信号量，wait之后当前线程会被阻塞直到 lock signal。
在用的时候注意，首先对lock对象进行lock.

> NSConditionLock（条件锁）

```
@interface NSConditionLock : NSObject <NSLocking> {
@private
    void *_priv;
}
//初始化一个NSConditionLock对象
- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;

@property (readonly) NSInteger condition;  //锁的条件

//满足条件时加锁
- (void)lockWhenCondition:(NSInteger)condition;


- (BOOL)tryLock;
//如果接收对象的condition与给定的condition相等，则尝试获取锁，不阻塞线程
- (BOOL)tryLockWhenCondition:(NSInteger)condition;

//解锁后，重置锁的条件
- (void)unlockWithCondition:(NSInteger)condition;

- (BOOL)lockBeforeDate:(NSDate *)limit;

//在指定时间前尝试获取锁，若成功则返回YES 否则返回NO
- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;

@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));

@end
```

> NSRecursiveLock（递归锁）

递归锁，它允许同一线程多次加锁，而不会造成死锁。NSLock会造成死锁。

```
NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];
//    NSLock *lock = [[NSLock alloc] init];
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        static void (^block)(int);
        block = ^(int value) {
            //加锁
            [lock lock];
            if (value > 0) {
                NSLog(@"%d",value);
                sleep(2);
                //递归调用
                block(--value);
            }
            //解锁
            [lock unlock];
        };
        //调用代码块
        block(10);
    });
```

> 自旋锁（OSSpinLock）

自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，其作用是为了解决某项资源的互斥使用。

自旋锁的缺点：

1. 自旋锁一直占用CPU，他在未获得锁的情况下，一直运行－－自旋，所以占用着CPU，如果不能在很短的时 间内获得锁，这无疑会使CPU效率降低。
2. 在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁，调用有些其他函数也可能造成死锁，如 copy_to_user()、copy_from_user()、kmalloc()等。

> 互斥锁

在多线程的使用中，我们可以使用互斥锁来使多个线程保持同步。互斥锁会使等待的线程阻塞进入休眠状态，以使其他线程可以工作，当当前线程解锁时，会主动去将其他线程激活，这个过程包含了上下文的切换，cpu抢占，信号发送等开销，很明显，互斥锁的起始开销有些大，效率低于自旋锁。

互斥锁的使用过程中，主要有`pthread_mutex_init`，`pthread_mutex_destory`，`pthread_mutex_lock`，`pthread_mutex_unlock`这几个函数以完成锁的初始化，锁的销毁，上锁和释放锁操作。

1.声明一个互斥锁

```
pthread_mutex_t _lock;
  //初始化
pthread_mutex_init(&_lock, NULL);
```

2.上锁 解锁

```
//上锁
pthread_mutex_lock(&_lock)
//这里加入可能产生死锁的操作 比如像文件写入  读取之类
//解锁 
pthread_mutex_unlock(&_lock)
```

3.释放锁

`pthread_mutex_destroy(&_lock)`




# 4. 信息安全

## 4.1 (防止反编译、APP安全)

> HTTPS配置

[HTTPS双向配置](http://www.cnblogs.com/OC888/p/6616583.html)

[HTTPS配置](https://www.jianshu.com/p/8c128d9c9681)

[HTTPS配置](https://www.jianshu.com/p/8b836ceaca0a)

> 本地数据加密

对NSUserDefaults，sqlite存储文件数据加密，保护帐号和关键信息

* FMDB数据库加密
 * 对数据库内容加密，存的时候加密，用得时候解密。
 * 直接对数据库文件加密（pod 'FMDB/SQLCipher'）[FMDB](http://blog.bombox.org/2016-04-18/sqlcipher-start/) [FMDB加密](https://github.com/ccgus/fmdb)。

> URL编码加密

对程序中出现的URL进行编码加密，防止URL被静态分析。(YYKit 分类)

`admin.php?act=zhongguo&tx=123` 编码 `admin.php%3Fact%3Dzhongguo%26tx%3D123`

```
？=> %3F
= => %3D
% => %25
& => %26
\ => %5C
```

> 网络传输数据加密

[防抓包](https://www.jianshu.com/p/4682aecf162d?open_source=weibo_search)

对客户端传输数据提供加密方案，有效防止通过网络接口的拦截获取数据。

签名实现方案：

```
#pragma mark - HeaderAndSign

/**
 设置header字段

 @param parameters body中的参数
 */
- (void)setHTTPHeaderWithBodyParameters:(NSDictionary *)parameters {
    NSDictionary *HTTPHeaderField = [self theHTTPHeaderFieldNoSign];
    NSDictionary *unsignedParameters = [self theUnsignedParameters:parameters];
    NSString *sign = [self signStringWithParameters:unsignedParameters];
    [HTTPHeaderField enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {
        [self.requestSerializer setValue:obj forHTTPHeaderField:key];
    }];
    [self.requestSerializer setValue:kSafeString(sign) forHTTPHeaderField:@"wkch-sign"];
}

/**
 获取不包括sign的header参数

 @return header参数
 */
- (NSDictionary *)theHTTPHeaderFieldNoSign {

    NSString *uniqueId = [JGKeyChainDataManager readUUID];
    if (isEmpty(uniqueId)) {
        uniqueId = [JGKeyChainDataManager createUUID];
        [JGKeyChainDataManager saveUUID:uniqueId];
    }
    NSString *version = ([[NSBundle mainBundle] infoDictionary][@"CFBundleShortVersionString"]);
    NSString *timestamp = [NSString stringWithFormat:@"%.f", [[NSDate date] timeIntervalSince1970]];
    NSString *mobileAccessToken = kSafeString(kUserInfo.userInfoModel.accessToken);
    NSString *uIdString = isEmpty(kUserInfo.userInfoModel.id) ? @"0" : kSafeString(kUserInfo.userInfoModel.id);
    // deviceType 设备：1：安卓 2：iOS
    NSDictionary *dictionary = @{
                                 @"deviceType" : @"2",
                                 @"uniqueId" : kSafeString(uniqueId),
                                 @"version" : kSafeString(version),
                                 @"app" : @"bundle-id",
                                 @"timestamp" : kSafeString(timestamp),
                                 @"uId" : uIdString,
                                 @"mobileAccessToken" : kSafeString(mobileAccessToken)
                                 };
    return dictionary;
}

/**
 获取未签名的所有参数

 @param params 参数
 @return 未签名的所有参数
 */
- (NSDictionary *)theUnsignedParameters:(NSDictionary *)params {
    NSDictionary *headerDictionary = [self theHTTPHeaderFieldNoSign];
    NSMutableDictionary *muDictionary = [NSMutableDictionary dictionaryWithDictionary:headerDictionary];
    if (params) {
        [muDictionary addEntriesFromDictionary:params];
    }
    return muDictionary;
}

/**
 获取加密后的sign字符串

 @param parameters 所有参数
 @return sign字符串
 */
- (NSString *)signStringWithParameters:(NSDictionary *)parameters {
    
    NSStringCompareOptions comparisonOptions = (NSCaseInsensitiveSearch |
                                                NSNumericSearch |
                                                NSWidthInsensitiveSearch |
                                                NSForcedOrderingSearch);
    NSComparator sort = ^(NSString *obj1, NSString *obj2) {
        NSRange range = NSMakeRange(0, obj1.length);
        return [obj1 compare:obj2 options:comparisonOptions range:range];
    };
    NSArray *allKeys = parameters.allKeys;
    NSArray *sortedAllKeys = [allKeys sortedArrayUsingComparator:sort];
    NSMutableArray *keyValues = [[NSMutableArray alloc] initWithCapacity:sortedAllKeys.count];
    for (NSString *key in sortedAllKeys) {
        NSString *keyValue = [NSString stringWithFormat:@"%@=%@",key, parameters[key]];
        [keyValues addObject:keyValue];
    }
    
    NSString *sign = [keyValues componentsJoinedByString:@"&"];
    if (isEmpty(sign)) {
        return @"";
    }
   
    return [sign md5Hash];
}
```


> 方法体，方法名高级混淆

对应用程序的方法名和方法体进行混淆，保证源码被逆向后无法解析代码。

> 程序结构混排加密

对应用程序逻辑结构进行打乱混排，保证源码可读性降到最低

> 借助第三方APP加固，例如：网易云易盾

## 4.2 加密解密

* 对称加密是***最快速、最简单***的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。
* 非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。***安全性高，但加密与解密速度慢***

> **Base64(对称)**

大致以“=”号结尾

> **AES(对称)**

![](https://wtj900.github.io/img/interview/AES加解密过程.png)

高级加密标准（英语：Advanced Encryption Standard，缩写：AES），是一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。

那么为什么原来的DES会被取代呢，，原因就在于其使用56位密钥，比较容易被破解。而AES可以使用128、192、和256位密钥，并且用128位分组加密和解密数据，相对来说安全很多。完善的加密算法在理论上是无法破解的，除非使用穷尽法。使用穷尽法破解密钥长度在128位以上的加密数据是不现实的，仅存在理论上的可能性。统计显示，即使使用目前世界上运算速度最快的计算机，穷尽128位密钥也要花上几十亿年的时间，更不用说去破解采用256位密钥长度的AES算法了。

目前世界上还有组织在研究如何攻破AES这堵坚厚的墙，但是因为破解时间太长，AES得到保障，但是所用的时间不断缩小。随着计算机计算速度的增快，新算法的出现，AES遭到的攻击只会越来越猛烈，不会停止的。

AES现在广泛用于金融财务、在线交易、无线通信、数字存储等领域，经受了最严格的考验，但说不定哪天就会步DES的后尘。

> **MD5(非对称)**

历史版本有MD2、MD4、MD5，消息摘要算法各个版本间的结果是不一样的。MD5是目前广泛使用的版本，不过其安全性多年前就开始被质疑（碰撞算法）。于是在2008年提出了MD6算法，其后MD6历经数次改进，目前还是试行方案阶段，未被正式使用。

消息摘要算法，32位=16个2位16进制。

> **SHA(非对称)**

安全散列算法,包括SHA-1、SHA-224、SHA-256、SHA-384，和SHA-512,和MD5类似，但安全性要高于MD5，运算性能有低于MD5。

> **RSA(非对称)**

* 加密/解密和签名/验签过程

A->B:

1. A提取消息m的消息摘要h(m),并使用自己的私钥对摘要h(m)进行加密,生成签名s
2. A将签名s和消息m一起,使用B的公钥进行加密,生成密文c,发送给B

B:

1. B接收到密文c,使用自己的私钥解密c得到明文m和数字签名s
2. B使用A的公钥解密数字签名s解密得到H(m)
3. B使用相同的方法提取消息m的消息摘要h(m)
4. B比较两个消息摘要。相同则验证成功;不同则验证失败

例：PHP后台，邀请码，对用户敏感信息进行加密

# 5. 语法

## 5.1 const常量与define宏定义
### 5.1.1 const与#define的区别
```
#define RADIUS 100;
const  float   RADIUS = 100;
```

1. 编译器处理方式不同
    * define宏是在预处理阶段展开。
    * const常量是编译运行阶段使用。
2. 类型和安全检查不同
    * define宏没有类型，不做任何类型检查，仅仅是展开。
    * const常量有具体的类型，在编译阶段会执行类型检查。
3. 存储方式不同
    * define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）
    * const常量会在内存中分配(可以是堆中也可以是栈中)。
4. `const`可以节省空间，避免不必要的内存分配.
>
'#define PI 3.14159 //常量宏  
const doulbe Pi=3.14159; //此时并未将Pi放入ROM中  
double i=Pi; //此时为Pi分配内存，以后不再分配！  
double I=PI; //编译期间进行宏替换，分配内存  
double j=Pi; //没有内存分配  
double J=PI; //再进行宏替换，又一次分配内存   
`const`定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象`#define`一样给出的是立即数，所以，`const`定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 `#define`定义的常量在内存中有若干个拷贝。

5. 提高了效率 
> 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。

6. 宏替换只作替换，不做计算，不做表达式求解
    * 宏预编译时就替换了，程序运行时，并不分配内存。

### 5.1.2 const与#define的比较
C++ 语言可以用const来定义常量，也可以用 #define来定义常量。但是前者比后者有更多的优点：

1. const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。
2. 有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。

## 5.2 数组（字典）中添加弱引用；NSPointerArray（NSArray）、NSHashTable（NSSet）、NSMapTable（NSDictionary）

自定义弱引用：

* 通过NSValue的方法`+ valueWithNonretainedObject: `和`nonretainedObjectValue`存取对象

```
- (nullable id)objectForKey:(id<NSCopying>)aKey {
    NSValue *value = [self objectForKey:aKey];
    
    return value.nonretainedObjectValue;
}

- (void)fm_setObject:(id)anObject forKey:(id <NSCopying>)aKey {
    NSValue *value = [NSValue valueWithNonretainedObject:anObject];
    [self setObject:value forKey:aKey];
}

- (void)fm_setDictionary:(NSDictionary *)otherDictionary {
    [otherDictionary enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key,
                                                         id  _Nonnull obj,
                                                         BOOL * _Nonnull stop) {
        [self fm_setObject:obj forKey:key];
    }];
}
```

* 用block封装与解封

```
typedef id (^WeakReference)(void);

WeakReference makeWeakReference(id object) {
    __weak id weakref = object;
    return ^{
        return weakref;
    };
}

id weakReferenceNonretainedObjectValue(WeakReference ref) {
    return ref ? ref() : nil;
}
```

```
- (void)weak_setObject:(id)anObject forKey:(NSString *)aKey {
    [self setObject:makeWeakReference(anObject) forKey:aKey];
}

- (void)weak_setObjectWithDictionary:(NSDictionary *)dic {
    for (NSString *key in dic.allKeys) {
        [self setObject:makeWeakReference(dic[key]) forKey:key];
    }
}

- (id)weak_getObjectForKey:(NSString *)key {
    return weakReferenceNonretainedObjectValue(self[key]);
}
```

* 使用NSProxy 的子类,像YYKit 这套框架就是用的这种方法

```
@interface YYWeakProxy : NSProxy

/**
 The proxy target.
 */
@property (nullable, nonatomic, weak, readonly) id target;

/**
 Creates a new weak proxy for target.
 @param target Target object.
 @return A new proxy object.
 */
- (instancetype)initWithTarget:(id)target;

+ (instancetype)proxyWithTarget:(id)target;

@end
```

```
@implementation YYWeakProxy

- (instancetype)initWithTarget:(id)target {
    _target = target;
    return self;
}

+ (instancetype)proxyWithTarget:(id)target {
    return [[YYWeakProxy alloc] initWithTarget:target];
}

- (id)forwardingTargetForSelector:(SEL)selector {
    return _target;
}

- (void)forwardInvocation:(NSInvocation *)invocation {
    void *null = NULL;
    [invocation setReturnValue:&null];
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector {
    return [NSObject instanceMethodSignatureForSelector:@selector(init)];
}

- (BOOL)respondsToSelector:(SEL)aSelector {
    return [_target respondsToSelector:aSelector];
}

//... 

@end
```

```
@implementation MyView {
    NSTimer *_timer;
}

- (void)initTimer {
    YYWeakProxy *proxy = [YYWeakProxy proxyWithTarget:self];
    _timer = [NSTimer timerWithTimeInterval:0.1
                                     target:proxy
                                   selector:@selector(tick:)
                                   userInfo:nil
                                    repeats:YES];
}

- (void)tick:(NSTimer *)timer {...}
@end
```

## 5.3 @private @protected @public @package

@private 私有的，也就是只有自己有，别人谁都不可用，哪怕亲如自己的孩子。

@protected 受保护的，他自己可以用，自己的孩子也是可以共享的。

@public 公共的，谁都可以用，只要你有这个类的对象，就可以拿到public下的变量。

@package 这个主要是用于框架类。

## 5.4 `__strong` `__weak` `__unsafe_unretained` `__autoreleasing`

```
    Person *p = [Person new];
    p.name = @"小明";
    Person *p1 = p;
    NSLog(@"1---p=%@,p1=%@,p1.name=%@",p,p1,p1.name);
    p = nil;
    NSLog(@"2---p=%@,p1=%@,p1.name=%@",p,p1,p1.name);
    
    //1---p=<Person: 0x600000df8d80>,p1=<Person: 0x600000df8d80>,p1.name=小明
    //2---p=(null),p1=<Person: 0x600000df8d80>,p1.name=小明
    //p已经指向nil,但是p1还能访问name属性,说明对象没有被销毁，默认指针被__strong修饰
```

```
    Person *p = [Person new];
    p.name = @"小明";
    __weak Person *p1 = p;
    NSLog(@"1---p=%@,p1=%@,p1.name=%@",p,p1,p1.name);
    p = nil;
    NSLog(@"2---p=%@,p1=%@,p1.name=%@",p,p1,p1.name);
    
    //1---p=<Person: 0x600002628680>,p1=<Person: 0x600002628680>,p1.name=小明
    //2---p=(null),p1=(null),p1.name=(null)
    //p指向nil,p1为弱指针,p1指向nil
```

```
    Person *p = [Person new];
    p.name = @"小明";
    __unsafe_unretained Person *p1 = p;
    NSLog(@"1---p=%@,p1=%@,p1.name=%@",p,p1,p1.name);
    p = nil;
    NSLog(@"2---p=%@,p1=%@,p1.name=%@",p,p1,p1.name);
    //p指向nil,p1的弱引用指针不会销毁，会继续指向对象的地址,对象已经销毁,此时p1访问的是"僵尸"对象,崩溃
```

```
    __autoreleasing表示在autorelease pool中自动释放对象的引用
```