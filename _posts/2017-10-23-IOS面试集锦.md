---
layout:     post
title:      IOS面试集锦
subtitle:   面试-看这里就足够了-直通BAT
date:       2017-10-23
author:     JT
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - iOS
    - 面试
---

# 1. 架构

## 1.1 架构

### 1.1.1 架构


# 2. 网络

## 2.1 网络

### 2.1.1 网络


# 3. 多线程

## 3.1 多线程

### 3.1.1 多线程


# 4. 信息安全

## 4.1 怎么防止别人动态在你程序生成代码（怎么防止别人反编译你的app）


> 本地数据加密

对NSUserDefaults，sqlite存储文件数据加密，保护帐号和关键信息
> URL编码加密

对程序中出现的URL进行编码加密，防止URL被静态分析
> 网络传输数据加密

对客户端传输数据提供加密方案，有效防止通过网络接口的拦截获取数据
> 方法体，方法名高级混淆

对应用程序的方法名和方法体进行混淆，保证源码被逆向后无法解析代码
> 程序结构混排加密

对应用程序逻辑结构进行打乱混排，保证源码可读性降到最低
> 借助第三方APP加固，例如：网易云易盾

# 5. 语法

## 5.1 const常量与define宏定义
### 5.1.1 const与#define的区别
```
#define RADIUS 100;
const  float   RADIUS = 100;
```

1. 编译器处理方式不同
    * define宏是在预处理阶段展开。
    * const常量是编译运行阶段使用。
2. 类型和安全检查不同
    * define宏没有类型，不做任何类型检查，仅仅是展开。
    * const常量有具体的类型，在编译阶段会执行类型检查。
3. 存储方式不同
    * define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）
    * const常量会在内存中分配(可以是堆中也可以是栈中)。
4. `const`可以节省空间，避免不必要的内存分配.
>
'#define PI 3.14159 //常量宏  
const doulbe Pi=3.14159; //此时并未将Pi放入ROM中  
double i=Pi; //此时为Pi分配内存，以后不再分配！  
double I=PI; //编译期间进行宏替换，分配内存  
double j=Pi; //没有内存分配  
double J=PI; //再进行宏替换，又一次分配内存   
`const`定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象`#define`一样给出的是立即数，所以，`const`定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 `#define`定义的常量在内存中有若干个拷贝。

5. 提高了效率 
> 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。

6. 宏替换只作替换，不做计算，不做表达式求解
    * 宏预编译时就替换了，程序运行时，并不分配内存。

### 5.1.2 const与#define的比较
C++ 语言可以用const来定义常量，也可以用 #define来定义常量。但是前者比后者有更多的优点：

1. const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。
2. 有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。

