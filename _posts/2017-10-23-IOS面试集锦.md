---
layout:     post
title:      IOS面试集锦
subtitle:   面试-看这里就足够了-直通BAT
date:       2017-10-23
author:     JT
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - iOS
    - 面试
---

# 1. 架构

## 1.1 架构

### 1.1.1 架构


# 2. 网络

## 2.1 网络

### 2.1.1 网络


# 3. 多线程

## 3.1 多线程

### 3.1.1 多线程


# 4. 信息安全

## 4.1 怎么防止别人动态在你程序生成代码（怎么防止别人反编译你的app）


> 本地数据加密

对NSUserDefaults，sqlite存储文件数据加密，保护帐号和关键信息
> URL编码加密

对程序中出现的URL进行编码加密，防止URL被静态分析
> 网络传输数据加密

对客户端传输数据提供加密方案，有效防止通过网络接口的拦截获取数据
> 方法体，方法名高级混淆

对应用程序的方法名和方法体进行混淆，保证源码被逆向后无法解析代码
> 程序结构混排加密

对应用程序逻辑结构进行打乱混排，保证源码可读性降到最低
> 借助第三方APP加固，例如：网易云易盾

## 4.2 加密解密

* 对称加密是***最快速、最简单***的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。
* 非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。***安全性高，但加密与解密速度慢***


### 4.2.1 AES
#### 4.2.1.1 什么是AES？

***AES 是对称的加密算法（加密和解密用相同的密钥）***

![AES加解密过程](/Users/li/Desktop/AES加解密过程.png)

高级加密标准（英语：Advanced Encryption Standard，缩写：AES），是一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。

那么为什么原来的DES会被取代呢，，原因就在于其使用56位密钥，比较容易被破解。而AES可以使用128、192、和256位密钥，并且用128位分组加密和解密数据，相对来说安全很多。完善的加密算法在理论上是无法破解的，除非使用穷尽法。使用穷尽法破解密钥长度在128位以上的加密数据是不现实的，仅存在理论上的可能性。统计显示，即使使用目前世界上运算速度最快的计算机，穷尽128位密钥也要花上几十亿年的时间，更不用说去破解采用256位密钥长度的AES算法了。

目前世界上还有组织在研究如何攻破AES这堵坚厚的墙，但是因为破解时间太长，AES得到保障，但是所用的时间不断缩小。随着计算机计算速度的增快，新算法的出现，AES遭到的攻击只会越来越猛烈，不会停止的。

AES现在广泛用于金融财务、在线交易、无线通信、数字存储等领域，经受了最严格的考验，但说不定哪天就会步DES的后尘。

### 4.2.2 RSA

***RSA 是非对称的加密算法***

#### 4.2.2.1 加密/解密和签名/验签过程

A->B:

1. A提取消息m的消息摘要h(m),并使用自己的私钥对摘要h(m)进行加密,生成签名s
2. A将签名s和消息m一起,使用B的公钥进行加密,生成密文c,发送给B

B:

1. B接收到密文c,使用自己的私钥解密c得到明文m和数字签名s
2. B使用A的公钥解密数字签名s解密得到H(m)
3. B使用相同的方法提取消息m的消息摘要h(m)
4. B比较两个消息摘要。相同则验证成功;不同则验证失败


# 5. 语法

## 5.1 const常量与define宏定义
### 5.1.1 const与#define的区别
```
#define RADIUS 100;
const  float   RADIUS = 100;
```

1. 编译器处理方式不同
    * define宏是在预处理阶段展开。
    * const常量是编译运行阶段使用。
2. 类型和安全检查不同
    * define宏没有类型，不做任何类型检查，仅仅是展开。
    * const常量有具体的类型，在编译阶段会执行类型检查。
3. 存储方式不同
    * define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）
    * const常量会在内存中分配(可以是堆中也可以是栈中)。
4. `const`可以节省空间，避免不必要的内存分配.
>
'#define PI 3.14159 //常量宏  
const doulbe Pi=3.14159; //此时并未将Pi放入ROM中  
double i=Pi; //此时为Pi分配内存，以后不再分配！  
double I=PI; //编译期间进行宏替换，分配内存  
double j=Pi; //没有内存分配  
double J=PI; //再进行宏替换，又一次分配内存   
`const`定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象`#define`一样给出的是立即数，所以，`const`定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 `#define`定义的常量在内存中有若干个拷贝。

5. 提高了效率 
> 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。

6. 宏替换只作替换，不做计算，不做表达式求解
    * 宏预编译时就替换了，程序运行时，并不分配内存。

### 5.1.2 const与#define的比较
C++ 语言可以用const来定义常量，也可以用 #define来定义常量。但是前者比后者有更多的优点：

1. const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。
2. 有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。

