---
layout:     post
title:      设计模式
subtitle:   面向对象之设计模式
date:       2019-01-23
author:     JT
header-img: img/post-bg-github-cup.jpg
catalog:    true
tags:
    - 设计模式
---

[23种设计模式全面解析](http://c.biancheng.net/design_pattern/)

## 设计原则

### 单一职责原则

###开放封闭原则

###里式替换原则

###接口隔离原则

###依赖倒转原则

###组合复用原则

###迪米特法则


## 设计模式

> 学习设计模式需要了解每种模式的使用场景和优缺点

设计模式按其目的分为三类：

* 创建型，共六种：简单工厂、工厂方法、抽象工厂、单例、建造者、原型
* 结构型，共七种：适配器(Adapter)、桥接(Bridge)、组合(Composite)、装饰器(Decorator)、外观(Facade)、享元(Flyweight)、代理(Proxy)  [ABCDFFP]
* 行为型，共十一种：策略、模板、观察者、迭代器、责任链、命令、备忘录、状态、访问者、中介者、解释器

### 创建型

软件设计的过程是循序渐进，一步步来的。在软件设计中对象的创建和使用时分开的，因为对象的创建会消耗掉系统很多资源，所以单独对对象的创建进行研究，从而能够高效地创建对象，这是创建型设计模式要探讨和解决的问题。

#### 简单工厂

![](https://wtj900.github.io/img/designpatterns/simple_factory.png)

通过**一个工厂**，根据不同的要求生产不同的产品，根据生产的产品执行产品特性。

优点：增加产品只需要增加对应的产品类并修改工厂增加判断条件即可，去除了与具体产品的依赖；

缺点：增加产品需要修改工厂方法，违反了“开放-封闭”原则

#### 工厂方法

> 只生产同级别的产品，例如电视机工厂只生产电视机

![](https://wtj900.github.io/img/designpatterns/factory_method.png)

定义一个抽象方法的接口类，实现多个工厂方法，不同的方法中生产不同的产品，选择确定的工厂方法生产产品，根据生产的产品执行产品特性。

优点：解决了简单工厂违反“开放-封闭”原则的问题

缺点：每增加一个产品，就需要增加一个工厂

#### 抽象工厂

> 抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。

一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。

![](https://wtj900.github.io/img/designpatterns/abstract_factory.png)

使用抽象工厂模式一般要满足以下条件。
系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。
系统一次只可能消费其中某一族产品，即同族的产品一起使用。

优点：可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
当增加一个新的产品族时不需要修改原代码，满足开闭原则。

缺点：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。

#### 单例
#### 建造者
#### 原型

### 结构型

解决了对象创建问题后，一个对象的组成和多个对象间的依赖关系成了开发人员关注的焦点问题。因为，如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码健壮性及耦合性等。这是结构型模式的关注点。

#### 适配器(Adapter)
#### 桥接(Bridge)
#### 组合(Composite)
#### 装饰器(Decorator)
#### 外观(Facade)
#### 享元(Flyweight)
#### 代理(Proxy)

### 行为型

在对象的创建和对象的结构问题解决后，就剩下对象的行为问题。如果设计的好，对象的行为就会更清晰，对象之间的协作效率会提高。

#### 策略
#### 模板
#### 观察者
#### 迭代器
#### 责任链
#### 命令
#### 备忘录
#### 状态
#### 访问者
#### 中介者
#### 解释器


![](https://wtj900.github.io/img/sql/sql-structure.png)


  
  
  
  
  
  
  