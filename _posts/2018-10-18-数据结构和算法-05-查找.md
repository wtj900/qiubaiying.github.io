---
layout:     post
title:      数据结构和算法
subtitle:   查找
date:       2018-10-18
author:     JT
header-img: img/post-bg-github-cup.jpg
catalog:    true
tags:
    - 数据结构和算法
---

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

## 概要

查找分为静态查找和动态查找。

* 静态查找：数据集合稳定，不需要添加删除元素
* 动态查找：数据集合在查找过程中需要同时添加或删除元素

## 静态查找

> 顺序查找

按照顺序进行比对，相等就是查找结果，不相等就没有结果。

时间复杂度：O(n)。

> 插值查找（按比例查找）

在折半查找的基础上，按比率进行查找，适用于数据量大且分布均匀的数据，否则效率低于折半查找。

`mid = low + ((key - a[low]) / (a[high] - a[low])) * (high - low);`

时间复杂的：O(logn)。

> 斐波那契查找（黄金比例）

斐波那契数列(a(n) = a(n-1) + a(n-2)): 1，1，2，3，5，8，13，21，...

后二数之比2/3，3/5，5/8，8/13，13/21，... 无限接近黄金比例（0.618）。

将源数据的个数映射到斐波那契数列中，根据斐波那契数列的特性对源数据进行分割查找比较，即比例为0.618的插值查找。

时间复杂的：O(logn)。

> 线性索引查找

为数据建立已排序索引表，根据索引表查找数据。

>> 稠密索引

建立和数据相同当量的索引表，适用于数据量不是很大的场景。

>> 分块索引

![](https://wtj900.github.io/img/DataAlgorithm/分块索引.png)

>> 倒排索引

![](https://wtj900.github.io/img/DataAlgorithm/倒排索引.png)

## 二叉排序树（二叉查找树）

![](https://wtj900.github.io/img/DataAlgorithm/二叉排序树创建.png)

二叉排序树性质：

* 左子树上所有结点的值均小于他的根结构的值
* 右子树上所有结点的值均大于他的根结构的值
* 左、右子树也分别为二叉排序树（递归）

> 二叉排序树查找

![](https://wtj900.github.io/img/DataAlgorithm/二叉排序树查找.png)

> 二叉排序树插入

![](https://wtj900.github.io/img/DataAlgorithm/二叉排序树插入.png)

> 二叉排序树删除

* 如果该结点是叶子结点，直接删除
* 如果该结点只有左子树或右子树，直接删除，然后接上
* 如果既有左子树又有右子树，采用中序排序找到其前驱或后继替换，然后接上

![](https://wtj900.github.io/img/DataAlgorithm/二叉排序树删除-01.png)
![](https://wtj900.github.io/img/DataAlgorithm/二叉排序树删除-02.png)
![](https://wtj900.github.io/img/DataAlgorithm/二叉排序树删除-03.png)

## 平衡二叉排序树

平衡二叉排序树的特点：

* 左子树和右子树都是平衡二叉树
* 左子树和右子树的深度只差（平衡因子BF）的绝对值不超过1

插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。

演示一组数据怎么组成一棵AVL树。

`int a[] = {4,3,2,7,9,11,10}; `

* 插入4，如图：![](https://wtj900.github.io/img/DataAlgorithm/平衡二叉排序树-01.png)，平衡因子为0.
* 插入3，如图：![](https://wtj900.github.io/img/DataAlgorithm/平衡二叉排序树-02.png)，4的平衡因子因为4的左子树增长了，1-0=1
* 插入2，如图：![](https://wtj900.github.io/img/DataAlgorithm/平衡二叉排序树-03.png)，显然4的平衡因子大于1了，为了保持平衡那我们就这样做：让4节点的左孩子指向3的右子树（此时为NULL），让3的右孩子指向4，让树根指向3，如图![](https://wtj900.github.io/img/DataAlgorithm/平衡二叉排序树-04.png)，这种操作我们规定为右旋操作。
* 插入7，如图：![](https://wtj900.github.io/img/DataAlgorithm/平衡二叉排序树-05.png)
* 插入9，如图：![](https://wtj900.github.io/img/DataAlgorithm/平衡二叉排序树-06.png)，显然节点4不平衡了。那我们就把4的右孩子7的左子树（此时为NULL），让7的左孩子指向4，让3的右孩子指向7，如图：![](https://wtj900.github.io/img/DataAlgorithm/平衡二叉排序树-07.png)，我们规定此操作为左旋操作，此图是以4为根进行旋转。
* 插入11，如图：![](https://wtj900.github.io/img/DataAlgorithm/平衡二叉排序树-08.png)，显然3节点，不平衡了，大家都应该知道以3为根进行左旋。让3的右孩子指向7的左子树（此时为4）。7的左孩子指向3，根指向7，如下图所示：![](https://wtj900.github.io/img/DataAlgorithm/平衡二叉排序树-09.png)
* 插入10，如图：![](https://wtj900.github.io/img/DataAlgorithm/平衡二叉排序树-10.png)，显然节点9不平衡，且是右边高，那我们左旋吧，左旋后的效果是上图右图所示。显然这是不对的，10比11小，但在11的右孩子上。（根本原因是9和11的平衡因子符号不同）那我们在怎么办呢,看下图吧：![](https://wtj900.github.io/img/DataAlgorithm/平衡二叉排序树-11.png)，以11为根先右旋，![](https://wtj900.github.io/img/DataAlgorithm/平衡二叉排序树-12.png)，再以9为根左旋。








```

#define EH 0     // 等高
#define LH 1     // 左高
#define RH -1    // 右高

typedef struct _BitNode
{
    int data;
    int bf;   //平衡因子
    struct _BitNode *lchild, *rchild;
} BitNode, *BiTree;

void R_Rotate(BiTree *T)
{
    BiTree p;             
    p=T->lchild;          // 假如此时T指向4，则p指向3；
    T->lchild=p->rchild;  // 把3的右子树挂接到4的左子树上（此例子3右子树为空）
    p->rchild=T;          // 让3的右孩子指向4.
    T=p;                  // 根指向节点3
}

void L_Rotate(BiTree *T)
{
    BiTree p;
    p=T->rchild;         //假如此时T指向4，则p指向7.
    T->rchild=p->lchild; //让7的左子树挂接到4的右子树上
    p->lchild=T;         //让7的左孩子指向4
    T=p;                 //树根指向7
}





```













