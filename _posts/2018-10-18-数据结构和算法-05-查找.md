---
layout:     post
title:      数据结构和算法
subtitle:   查找
date:       2018-10-18
author:     JT
header-img: img/post-bg-github-cup.jpg
catalog:    true
tags:
    - 数据结构和算法
---

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

## 概要

查找分为静态查找和动态查找。

* 静态查找：数据集合稳定，不需要添加删除元素
* 动态查找：数据集合在查找过程中需要同时添加或删除元素

## 静态查找

> 顺序查找

按照顺序进行比对，相等就是查找结果，不相等就没有结果。

时间复杂度：O(n)。

> 插值查找（按比例查找）

在折半查找的基础上，按比率进行查找，适用于数据量大且分布均匀的数据，否则效率低于折半查找。

`mid = low + ((key - a[low]) / (a[high] - a[low])) * (high - low);`

时间复杂的：O(logn)。

> 斐波那契查找（黄金比例）

斐波那契数列(a(n) = a(n-1) + a(n-2)): 1，1，2，3，5，8，13，21，...

后二数之比2/3，3/5，5/8，8/13，13/21，... 无限接近黄金比例（0.618）。

将源数据的个数映射到斐波那契数列中，根据斐波那契数列的特性对源数据进行分割查找比较，即比例为0.618的插值查找。

时间复杂的：O(logn)。

> 线性索引查找

为数据建立已排序索引表，根据索引表查找数据。

>> 稠密索引

建立和数据相同当量的索引表，适用于数据量不是很大的场景。

>> 分块索引

![](https://wtj900.github.io/img/DataAlgorithm/分块索引.png)

>> 倒排索引

![](https://wtj900.github.io/img/DataAlgorithm/倒排索引.png)

## 二叉排序树（二叉查找树）

![](https://wtj900.github.io/img/DataAlgorithm/二叉排序树创建.png)

二叉排序树性质：

* 左子树上所有结点的值均小于他的根结构的值
* 右子树上所有结点的值均大于他的根结构的值
* 左、右子树也分别为二叉排序树（递归）

> 二叉排序树查找

![](https://wtj900.github.io/img/DataAlgorithm/二叉排序树查找.png)

> 二叉排序树插入

![](https://wtj900.github.io/img/DataAlgorithm/二叉排序树插入.png)

> 二叉排序树删除

* 如果该结点是叶子结点，直接删除
* 如果该结点只有左子树或右子树，直接删除，然后接上
* 如果既有左子树又有右子树，采用中序排序找到其前驱或后继替换，然后接上

![](https://wtj900.github.io/img/DataAlgorithm/二叉排序树删除-01.png)
![](https://wtj900.github.io/img/DataAlgorithm/二叉排序树删除-02.png)
![](https://wtj900.github.io/img/DataAlgorithm/二叉排序树删除-03.png)

## 平衡二叉排序树

平衡二叉排序树的特点：

* 左子树和右子树都是平衡二叉树
* 左子树和右子树的深度只差（平衡因子BF）的绝对值不超过1

插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。

演示一组数据怎么组成一棵AVL树。

`int a[] = {4,3,2,7,9,11,10}; `

* 插入4，如图：![](https://wtj900.github.io/img/DataAlgorithm/平衡二叉排序树-01.png)，平衡因子为0.
* 插入3，如图：![](https://wtj900.github.io/img/DataAlgorithm/平衡二叉排序树-02.png)，4的平衡因子因为4的左子树增长了，1-0=1
* 插入2，如图：![](https://wtj900.github.io/img/DataAlgorithm/平衡二叉排序树-03.png)，显然4的平衡因子大于1了，为了保持平衡那我们就这样做：让4节点的左孩子指向NULL，让3的右孩子指向4，让树根指向3，如图![](https://wtj900.github.io/img/DataAlgorithm/平衡二叉排序树-04.png)，这种操作我们规定为右旋操作。








```

#define EH 0     // 等高
#define LH 1     // 左高
#define RH -1    // 右高

typedef struct _BitNode
{
    int data;
    int bf;   //平衡因子
    struct _BitNode *lchild, *rchild;
} BitNode, *BiTree;







```













