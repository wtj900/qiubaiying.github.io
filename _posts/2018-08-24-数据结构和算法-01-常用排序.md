---
layout:     post
title:      数据结构和算法
subtitle:   排序
date:       2018-08-24
author:     JT
header-img: img/post-bg-github-cup.jpg
catalog:    true
tags:
    - 数据结构和算法
---

## 概要

> 内排序和外排序

* 内排序：所有的排序操作都在内存中进行。

* 外排序：要记录的数据太多，不能都存放在内存中，整个排序操作需要进行内存和外存（硬盘）的多次交换；

> 排序的稳定性

假设Ki=Kj(1<=i<=n,1<=j<=n,i!=j),且在排序前的序列中Ki领先于Kj(即i<j)。

如果，如果排序后Ki扔领先于Kj，则称所用的排序方法是稳定的。

反之，若可能使得排序后的序列中Kj领先于Ki，则称所用的排序方法是不稳定的。

> 影响排序算法性能的要素

* 时间性能：主要比较移动的操作
* 辅助空间：是否借助外存储
* 算法的复杂度：算法本身的复杂度

> 数组交换

```
/**
 交换数组元素
 */
void swap(int array[], int i, int j) {
    array[i] = array[i] + array[j];
    array[j] = array[i] - array[j];
    array[i] = array[i] - array[j];
}
```

## 冒泡排序

冒泡排序的基本思想是，对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端，最终达到完全有序。

![](https://wtj900.github.io/img/DataAlgorithm/冒泡排序.png)

> 代码实现

```
/**
 冒泡排序
 */
void bubble_sort(int array[], int n) {
    
    for (int i = 0; i < n; i++) {
        bool flag = true; //设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已然完成。
        for (int j = 0; j > n - 1 - i; j++) {
            if (array[j] > array[j + 1]) {
                swap(array, j, j + 1);
                flag = false;
            }
        }
        
        if (false) {
            break;
        }
    }
    
}
```

根据上面这种冒泡实现，若原数组本身就是有序的（这是最好情况），仅需n-1次比较就可完成；若是倒序，比较次数为 n-1+n-2+...+1=n(n-1)/2，交换次数和比较次数等值。所以，其时间复杂度依然为O(n2）。

## 选择排序



## 插入排序



## 希尔排序



## 堆排序



## 归并排序



## 快速排序




