---
layout:     post
title:      数据结构和算法
subtitle:   排序
date:       2018-08-24
author:     JT
header-img: img/post-bg-github-cup.jpg
catalog:    true
tags:
    - 数据结构和算法
---

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

## 概要

> 排序的稳定性

假设Ki=Kj(1<=i<=n,1<=j<=n,i!=j),且在排序前的序列中Ki领先于Kj(即i<j)。

如果，如果排序后Ki扔领先于Kj，则称所用的排序方法是稳定的。

反之，若可能使得排序后的序列中Kj领先于Ki，则称所用的排序方法是不稳定的。

> 排序算法分类

* 内排序：所有的排序操作都在内存中进行。

* 外排序：要记录的数据太多，不能都存放在内存中，整个排序操作需要进行内存和外存（硬盘）的多次交换；

![](https://wtj900.github.io/img/DataAlgorithm/排序.png)

> 排序算法比较

![](https://wtj900.github.io/img/DataAlgorithm/排序比较.png)

注：

1. 归并排序可以通过手摇算法将空间复杂度降到O（1），但是时间复杂度会提高。

2. 基数排序时间复杂度为O（N*M），其中N为数据个数，M为数据位数。

辅助记忆

* 时间复杂度记忆
 * 冒泡、选择、直接插入排序需要两个for循环，每次只关注一个元素，平均时间复杂度为O(\\(n^2\\)）（一遍找元素O(n)，一遍找位置O(n)）
 * 快速、归并、希尔、堆基于二分思想，log以2为底，平均时间复杂度为O(nlogn)（一遍找元素O(n)，一遍找位置O(logn)）
* 稳定性记忆-“快希选堆”（快牺牲稳定性） 
 * 排序算法的稳定性：排序前后相同元素的相对位置不变，则称排序算法是稳定的；否则排序算法是不稳定的。

> 影响排序算法性能的要素

* 时间性能：主要比较移动的操作
* 辅助空间：是否借助外存储
* 算法的复杂度：算法本身的复杂度

> 数组交换

```
/**
 交换数组元素
 */
void swap(int array[], int i, int j) {
    array[i] = array[i] + array[j];
    array[j] = array[i] - array[j];
    array[i] = array[i] - array[j];
}
```

## 冒泡排序

冒泡排序的基本思想是，对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端，最终达到完全有序。

![](https://wtj900.github.io/img/DataAlgorithm/冒泡排序.png)

> 代码实现

```
/**
 冒泡排序
 */
void bubble_sort(int array[], int n) {
    
    for (int i = 0; i < n; i++) {
        bool flag = true; //设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已然完成。
        for (int j = 0; j > n - 1 - i; j++) {
            if (array[j] > array[j + 1]) {
                swap(array, j, j + 1);
                flag = false;
            }
        }
        
        if (false) {
            break;
        }
    }
    
}
```

根据上面这种冒泡实现，若原数组本身就是有序的（这是最好情况），仅需n-1次比较就可完成；若是倒序，比较次数为 n-1+n-2+...+1=n(n-1)/2，交换次数和比较次数等值。所以，其时间复杂度依然为O(\\(n^2\\))。

## 选择排序

简单选择排序是最简单直观的一种算法，基本思想为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止，简单选择排序是不稳定排序。

在算法实现时，每一趟确定最小元素的时候会通过不断地比较交换来使得首位置为当前最小，交换是个比较耗时的操作。其实我们很容易发现，在还未完全确定当前最小元素之前，这些交换都是无意义的。我们可以通过设置一个变量min，每一次比较仅存储较小元素的数组下标，当轮循环结束之后，那这个变量存储的就是当前最小元素的下标，此时再执行交换操作即可。代码实现很简单，一起来看下。

> 代码实现

```
void selectSort(int array[], int n) {
    
    for (int i = 0; i < n - 1; i++) {
        int min = i;
        for (int j = i + 1; j < n; j++) {
            if (array[j] > array[min]) {
                min = j;
            }
        }
        
        if (min != i) {
            swap(array, i, min);
        }
    }
}
```

## 插入排序

直接插入排序基本思想是每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。

![](https://wtj900.github.io/img/DataAlgorithm/冒泡排序.png)

> 代码实现

```
void insertSort(int array[], int n) {
    
    for (int i = 1; i < n; i++) {
        int j = i;
        while (j > 0 && array[j - 1] > array[j]) {
            swap(array, j - 1, j);
            j--;
        }
    }
}
```

插入排序在最好情况下，需要比较n-1次，无需交换元素，时间复杂度为O(n);在最坏情况下，时间复杂度依然为O(\\(n^2\\))。但是在数组元素随机排列的情况下，插入排序还是要优于冒泡和选择两种排序的。

## 快速排序

## 堆排序

## 希尔排序

希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(\\(n^2\\))的第一批算法之一。

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。

简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。

我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2...1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。

![](https://wtj900.github.io/img/DataAlgorithm/希尔排序.png)

> 代码实现

```
void shellSort(int array[], int n) {
    
    for (int gap = n / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < n; i++) {
            int j = i;
            while (j >= gap && array[j] < array[j - gap]) {
                swap(array, j, j - gap);
                j -= gap;
            }
        }
    }
}
```

## 归并排序








