---
layout:     post
title:      Swift
subtitle:   一路学习心得
date:       2018-03-22
author:     JT
header-img: img/post-bg-swift-logo.jpg
catalog:    true
tags:
    - Swift
---


## 基本运算符
## 字符和字符串
## 集合类型
## 控制流
## 函数
## 闭包
## 枚举

>重点：关联值  原始值

### 1. 简介

枚举为一组相关值定义了一个通用类型，从而可以让你在代码中安全地操作这些值。

如果你熟悉 C ，那么你可能知道 C 中的枚举会给一组整数值分配相关的名称。Swift 中的枚举则更加灵活，并且不需给枚举中的每一个成员都提供值。如果一个值（所谓“原始”值）要被提供给每一个枚举成员，那么这个值可以是字符串、字符、任意的整数值，或者是浮点类型。

而且，枚举成员可以指定任意类型的值来与不同的成员值关联储存，这更像是其他语言中的 union 或variant 的效果。你可以定义一组相关成员的合集作为枚举的一部分，每一个成员都可以有不同类型的值的合集与其关联。

Swift 中的枚举是具有自己权限的一类类型。它们使用了许多一般只被类所支持的特性，例如计算属性用来提供关于枚举当前值的额外信息，并且实例方法用来提供与枚举表示的值相关的功能。枚举同样也能够定义初始化器来初始化成员值；而且能够遵循协议来提供标准功能。

### 2. 语法

你可以用 `enum` 关键字来定义一个枚举，然后将其所有的定义内容放在一个大括号`{}`中：

```swift
enum SomeEnumeration {
}
```

这是一个指南针的四个主要方向的例子：

```swift
enum CompassPoint {
	case north
	case south
	case eath
	case west
}
```

在一个枚举中定义的值（比如： north， south， east和 west）就是枚举的成员值（或成员）, `case`关键字则明确了要定义成员值。

> 不像 C 和 Objective-C 那样，Swift 的枚举成员在被创建时不会分配一个默认的整数值。
> 
> 在上文的 CompassPoint例子中， north， south， east和 west并不代表 0， 1， 2和 3。
> 
> 而相反，不同的枚举成员在它们自己的权限中都是完全合格的值，并且是一个在 CompassPoint中被显式定义的类型。

多个成员值可以出现在同一行中，要用逗号隔开：

```swift
enum Planet {
    case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune
}
```

每个枚举都定义了一个全新的类型。正如 Swift 中其它的类型那样，它们的名称（例如： CompassPoint和 Planet）需要首字母大写。给枚举类型起一个单数的而不是复数的名字，从而使得它们能够顾名思义：

```swift
var directionToHead = CompassPoint.west
directionToHead = .east
```

当与 CompassPoint中可用的某一值一同初始化时 directionToHead的类型会被推断出来。一旦 directionToHead以 CompassPoint类型被声明，你就可以用一个点语法把它设定成不同的 CompassPoint值：

**directionToHead的类型是已知的，所以当设定它的值时你可以不用写类型。这样做可以使得你在操作确定类型的枚举时让代码非常易读。**

### 3.使用 Switch 语句来匹配枚举值

你可以用 `switch` 语句来匹配每一个单独的枚举值：

```swift
directionToHead = .south
switch directionToHead {
case .north:
    print("Lots of planets have a north")
case .south:
    print("Watch out for penguins")
case .east:
    print("Where the sun rises")
case .west:
    print("Where the skies are blue")
}
```

当判断一个枚举成员时， switch语句**必须**是全覆盖的。如果 .west的 case被省略了，那么代码将不能编译，因为这时表明它并没有覆盖 CompassPoint的所有成员。要求覆盖所有枚举成员是因为这样可以保证枚举成员不会意外的被漏掉。

如果不能为所有枚举成员都提供一个 case，那你也可以提供一个 default情况来包含那些不能被明确写出的成员：

```swift
let somePlanet = Planet.earth
switch somePlanet {
case .earth:
    print("Mostly harmless")
default:
    print("Not a safe place for humans")
}
```

### 4. 关联值

之前几节中的栗子展示了枚举成员是怎样在他们各自的权限中被定义（和被分类）的。你可以给 Planet.earth设定常量或变量，然后再使用这个值。总之，有时将其它类型的关联值与这些成员值一起存储是很有用的。这样你就可以将额外的自定义信息和成员值一起储存，并且允许你在代码中每次调用这个成员时都能使用它。

你可以定义 Swift 枚举来存储任意给定类型的关联值，如果需要的话不同枚举成员关联值的类型可以不同。枚举与其他语言中的 discriminated unions, tagged unions, 或者 variants 类似。

举个栗子，假设库存跟踪系统需要按两个不同类型的条形码跟踪产品，一些产品贴的是用数字 0~9 的 UPC-A 格式一维条形码。每一个条码数字都含有一个“数字系统”位，之后是五个“制造商代码”数字和五个“产品代码”数字。而最后则是一个“检测”位来验证代码已经被正确扫描：

![](https://wtj900.github.io/img/swift-barcode_UPC_2x.png)



## 类和结构体
## 属性
## 方法
## 下标
## 继承
## 初始化
## 反初始化
## 自动引用计数
## 可选链
## 错误处理
## 类型转换
## 内嵌类型
## 扩展
## 协议
## 泛型
## 内存安全性
## 访问控制
## 高级运算符
