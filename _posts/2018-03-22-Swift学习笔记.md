---
layout:     post
title:      Swift教程
subtitle:   一路学习心得
date:       2018-03-22
author:     JT
header-img: img/post-bg-swift-logo.jpg
catalog:    true
tags:
    - Swift
---


## 基本运算符
## 字符和字符串
## 集合类型
## 控制流
## 函数
## 闭包
## 枚举

> 重点：关联值  原始值

### 1. 简介

枚举为一组相关值定义了一个通用类型，从而可以让你在代码中安全地操作这些值。

如果你熟悉 C ，那么你可能知道 C 中的枚举会给一组整数值分配相关的名称。Swift 中的枚举则更加灵活，并且不需给枚举中的每一个成员都提供值。如果一个值（所谓“原始”值）要被提供给每一个枚举成员，那么这个值可以是字符串、字符、任意的整数值，或者是浮点类型。

而且，枚举成员可以指定任意类型的值来与不同的成员值关联储存，这更像是其他语言中的 union 或variant 的效果。你可以定义一组相关成员的合集作为枚举的一部分，每一个成员都可以有不同类型的值的合集与其关联。

Swift 中的枚举是具有自己权限的一类类型。它们使用了许多一般只被类所支持的特性，例如计算属性用来提供关于枚举当前值的额外信息，并且实例方法用来提供与枚举表示的值相关的功能。枚举同样也能够定义初始化器来初始化成员值；而且能够遵循协议来提供标准功能。

### 2. 语法

你可以用 `enum` 关键字来定义一个枚举，然后将其所有的定义内容放在一个大括号`{}`中：

```swift
enum SomeEnumeration {
}
```

这是一个指南针的四个主要方向的例子：

```swift
enum CompassPoint {
	case north
	case south
	case eath
	case west
}
```

在一个枚举中定义的值（比如： north， south， east和 west）就是枚举的成员值（或成员）, `case`关键字则明确了要定义成员值。

> 不像 C 和 Objective-C 那样，Swift 的枚举成员在被创建时不会分配一个默认的整数值。
> 
> 在上文的 CompassPoint例子中， north， south， east和 west并不代表 0， 1， 2和 3。
> 
> 而相反，不同的枚举成员在它们自己的权限中都是完全合格的值，并且是一个在 CompassPoint中被显式定义的类型。

多个成员值可以出现在同一行中，要用逗号隔开：

```swift
enum Planet {
    case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune
}
```

每个枚举都定义了一个全新的类型。正如 Swift 中其它的类型那样，它们的名称（例如： CompassPoint和 Planet）需要首字母大写。给枚举类型起一个单数的而不是复数的名字，从而使得它们能够顾名思义：

```swift
var directionToHead = CompassPoint.west
directionToHead = .east
```

当与 CompassPoint中可用的某一值一同初始化时 directionToHead的类型会被推断出来。一旦 directionToHead以 CompassPoint类型被声明，你就可以用一个点语法把它设定成不同的 CompassPoint值：

**directionToHead的类型是已知的，所以当设定它的值时你可以不用写类型。这样做可以使得你在操作确定类型的枚举时让代码非常易读。**

### 3.使用 Switch 语句来匹配枚举值

你可以用 `switch` 语句来匹配每一个单独的枚举值：

```swift
directionToHead = .south
switch directionToHead {
case .north:
    print("Lots of planets have a north")
case .south:
    print("Watch out for penguins")
case .east:
    print("Where the sun rises")
case .west:
    print("Where the skies are blue")
}
```

当判断一个枚举成员时， switch语句**必须**是全覆盖的。如果 .west的 case被省略了，那么代码将不能编译，因为这时表明它并没有覆盖 CompassPoint的所有成员。要求覆盖所有枚举成员是因为这样可以保证枚举成员不会意外的被漏掉。

如果不能为所有枚举成员都提供一个 case，那你也可以提供一个 default情况来包含那些不能被明确写出的成员：

```swift
let somePlanet = Planet.earth
switch somePlanet {
case .earth:
    print("Mostly harmless")
default:
    print("Not a safe place for humans")
}
```

### 4. 关联值

之前几节中的栗子展示了枚举成员是怎样在他们各自的权限中被定义（和被分类）的。你可以给 Planet.earth设定常量或变量，然后再使用这个值。总之，有时将其它类型的关联值与这些成员值一起存储是很有用的。这样你就可以将额外的自定义信息和成员值一起储存，并且允许你在代码中每次调用这个成员时都能使用它。

你可以定义 Swift 枚举来存储任意给定类型的关联值，如果需要的话不同枚举成员关联值的类型可以不同。枚举与其他语言中的 discriminated unions, tagged unions, 或者 variants 类似。

举个栗子，假设库存跟踪系统需要按两个不同类型的条形码跟踪产品，一些产品贴的是用数字 0~9 的 UPC-A 格式一维条形码。每一个条码数字都含有一个“数字系统”位，之后是五个“制造商代码”数字和五个“产品代码”数字。而最后则是一个“检测”位来验证代码已经被正确扫描：
![](https://wtj900.github.io/img/swift-barcode_UPC_2x.png)

其它的产品则贴着二维码，它可以使用任何 ISO 8859-1 字符并且编码最长有 2953 个字符的字符串：
![](https://wtj900.github.io/img/swift-barcode_QR_2x.png)

这样可以让库存跟踪系统很方便的以一个由 4 个整数组成的元组来储存 UPC-A 条形码，然而二维码则可以被存储为一个任意长度的字符串中。

在 Swift 中，为不同类型产品条码定义枚举大概是这种姿势：

```swift 
enum Barcode {
    case upc(Int, Int, Int, Int)
    case qrCode(String)
}
```

这可以读作：

“定义一个叫做 Barcode的枚举类型，它要么用 (Int, Int, Int, Int)类型的关联值获取 upc 值，要么用 String 类型的关联值获取一个 qrCode的值。”

这个定义并不提供任何实际的 Int或者 String的值——它只定义当 Barcode常量和变量与 Barcode. upc或 Barcode. qrCode相同时可以存储的关联值的类型。

然后，新的条码就可以用任意一个类型来创建了：

```swift
var productBarcode = Barcode.upc(8, 85909, 51226, 3)
```

这个栗子创建了一个叫做 productBarcode的新变量而且给它赋值了一个 Barcode.upc的值关联了值为 (8, 85909, 51226, 3)的元组值。

同样的产品可以被分配一个不同类型的条码：

```swift
productBarcode = .qrCode("ABCDEFGHIJKLMNOP")
```

这时，最初的 Barcode.upc和它的整数值将被新的 Barcode.qrCode和它的字符串值代替。 Barcode类型的常量和变量可以存储一个 .upc或一个 .qrCode（和它们的相关值一起存储）中的任意一个，但是它们只可以在给定的时间内存储它们它们其中之一。

和以往一样，不同的条码类型可以用 switch 语句来检查。这一次，总之，相关值可以被提取为 switch 语句的一部分。你提取的每一个相关值都可以作为常量（用 let前缀) 或者变量（用 var前缀）在 switch的 case中使用：

```swift
switch productBarcode {
case .upc(let numberSystem, let manufacturer, let product, let check):
    print("UPC: \(numberSystem), \(manufacturer), \(product), \(check).")
case .qrCode(let productCode):
    print("QR code: \(productCode).")
}
```

如果对于一个枚举成员的所有的相关值都被提取为常量，或如果都被提取为变量，为了简洁，你可以用一个单独的 var或 let在成员名称前标注：

```swift
switch productBarcode {
case let .upc(numberSystem, manufacturer, product, check):
    print("UPC : \(numberSystem), \(manufacturer), \(product), \(check).")
case let .qrCode(productCode):
    print("QR code: \(productCode).")
}
```

### 5. 原始值

关联值中条形码的栗子展示了枚举成员是如何声明它们存储`不同类型`的相关值的。作为相关值的另一种选择，枚举成员可以用`相同类型`的默认值预先填充（称为原始值）。

这里有一个和已命名的枚举成员一起存储的原始 ASCII 码的例子：

```swift
enum ASCIIControlCharacter: Character {
    case tab = "\t"
    case lineFeed = "\n"
    case carriageReturn = "\r"
}
```

这里，一个叫做 ASCIIControlCharacter的枚举原始值被定义为类型 Character，并且被放置在了更多的一些 ASCII 控制字符中， Character值的描述见字符串和字符。

> 原始值与关联值不同。原始值是当你第一次定义枚举的时候，它们用来预先填充的值，正如上面的三个 ASCII 码。特定枚举成员的原始值是始终相同的。关联值在你基于枚举成员的其中之一创建新的常量或变量时设定，并且在你每次这么做的时候这些关联值可以是不同的。


### 6. 隐式指定的原始值

当你在操作存储整数或字符串原始值枚举的时候，你不必显式地给每一个成员都分配一个原始值。当你没有分配时，Swift 将会自动为你分配值。

实际上，当整数值被用于作为原始值时，每成员的隐式值都比前一个大一。如果第一个成员没有值，那么它的值是 0 。

下面的枚举是先前的 Planet枚举的简化，用整数原始值来代表从太阳到每一个行星的顺序：

```swift
enum Planet: Int {
    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune
}
```

在上面的例子中， Planet.mercury有一个明确的原始值 1 ， Planet.venus的隐式原始值是 2，以此类推。

当字符串被用于原始值，那么每一个成员的隐式原始值则是那个成员的名称。

下面的枚举是先前 CompassPoint枚举的简化，有字符串的原始值来代表每一个方位的名字：

```swift 
enum CompassPoint: String {
    case north, south, east, west
}
```

在上面的例子中， CompassPoint.south有一个隐式原始值 "south" ，以此类推。

你可以用 rawValue属性来访问一个枚举成员的原始值：

```swift
let earthsOrder = Planet.Earth.rawValue
// earthsOrder is 3
 
let sunsetDirection = CompassPoint.west.rawValue
// sunsetDirection is "west"
```

### 7. 从原始值初始化

如果你用原始值类型来定义一个枚举，那么枚举就会自动收到一个可以接受原始值类型的值的初始化器（叫做 rawValue的形式参数）然后返回一个枚举成员或者 nil 。你可以使用这个初始化器来尝试创建一个枚举的新实例。

这个例子从它的原始值 7来辨认出 Uranus ：

```swift
let possiblePlanet = Planet(rawValue: 7)
```

总之，不是所有可能的 Int值都会对应一个行星。因此原始值的初始化器总是返回可选的枚举成员。在上面的例子中， possiblePlanet的类型是 Planet? ，或者“可选项 Planet”

### 8. 递归枚举

枚举在对序号考虑固定数量可能性的数据建模时表现良好，比如用来做简单整数运算的运算符。这些运算符允许你组合简单的整数数学运算表达式比如5到更复杂的比如5+4.

数学表达式的一大特征就是它们可以内嵌。比如说表达式(5 + 4) * 2 在乘法右手侧有一个数但其他表达式在乘法的左手侧。因为数据被内嵌了，用来储存数据的枚举同样需要支持内嵌——这意味着枚举需要被递归。

递归枚举是拥有另一个枚举作为枚举成员关联值的枚举。当编译器操作递归枚举时必须插入间接寻址层。你可以在声明枚举成员之前使用`indirect`关键字来明确它是递归的。

举例来讲，这里有一个储存简单数学运算表达式的枚举：

```swift
enum ArithmeticExpression {
    case number(Int)
    indirect case addition(ArithmeticExpression, ArithmeticExpression)
    indirect case multiplication(ArithmeticExpression, ArithmeticExpression)
}
```

你同样可以在枚举之前写 `indirect` 来让整个枚举成员在需要时可以递归：

```swift
indirect enum ArithmeticExpression {
    case number(Int)
    case addition(ArithmeticExpression, ArithmeticExpression)
    case multiplication(ArithmeticExpression, ArithmeticExpression)
}
```

这个枚举可以储存三种数学运算表达式：单一的数字，两个表达式的加法，以及两个表达式的乘法。 addition 和 multiplication 成员拥有同样是数学表达式的关联值——这些关联值让嵌套表达式成为可能。比如说，表达式 (5 + 4) * 2 乘号右侧有一个数字左侧有其他表达式。由于数据是内嵌的，用来储存数据的枚举同样需要支持内嵌——这就是说枚举需要递归。下边的代码展示了为 (5 + 4) * 2 创建的递归枚举 ArithmeticExpression ：


```swift
let five = ArithmeticExpression.number(5)
let four = ArithmeticExpression.number(4)
let sum = ArithmeticExpression.addition(five, four)
let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))

```


递归函数是一种操作递归结构数据的简单方法。比如说，这里有一个判断数学表达式的函数：

```swift
func evaluate(_ expression: ArithmeticExpression) -> Int {
    switch expression {
    case let .number(value):
        return value
    case let .addition(left, right):
        return evaluate(left) + evaluate(right)
    case let .multiplication(left, right):
        return evaluate(left) * evaluate(right)
    }
}
 
print(evaluate(product))
// Prints "18"
```

这个函数通过直接返回关联值来判断普通数字。它通过衡量表达式左手侧和右手侧判断是加法还是乘法，然后对它们加或者乘。

源码：

```swift
indirect enum ArithmeticExpression {
    case number(Int)
    case addNumber(ArithmeticExpression, ArithmeticExpression)
    case mutiNumber(ArithmeticExpression, ArithmeticExpression)
    
    static func evalute(value: ArithmeticExpression) -> Int {
        
        switch value {
        case let .number(num):
            return num
        case let .addNumber(left, right):
            return evalute(value: left) + evalute(value: right)
        case let .mutiNumber(left, right):
            return evalute(value: left) * evalute(value: right)
        }
        
    }
    
}

let four = ArithmeticExpression.number(4)
let five = ArithmeticExpression.number(5)
let addNum = ArithmeticExpression.addNumber(four, five)
let mutiNum = ArithmeticExpression.mutiNumber(addNum, ArithmeticExpression.number(2))

ArithmeticExpression.evalute(value: mutiNum)
```

### 9. 位移枚举

OC枚举：

* 普通枚举 

```objc
typedef NS_ENUM(NSInteger, UIViewAnimationTransition) {
    UIViewAnimationTransitionNone,
    UIViewAnimationTransitionFlipFromLeft,
    UIViewAnimationTransitionFlipFromRight,
    UIViewAnimationTransitionCurlUp,
    UIViewAnimationTransitionCurlDown,
};
```

* 位移枚举

```objc
typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) {
    UIViewAutoresizingNone = 0,
    UIViewAutoresizingFlexibleLeftMargin = 1 << 0,
    UIViewAutoresizingFlexibleWidth = 1 << 1,
    UIViewAutoresizingFlexibleRightMargin= 1 << 2,
    UIViewAutoresizingFlexibleTopMargin= 1 << 3,
    UIViewAutoresizingFlexibleHeight= 1 << 4,
    UIViewAutoresizingFlexibleBottomMargin = 1 << 5
};
```

Swift枚举：

对于位掩码,Swift 给出的方案是:选项集合(option sets)。在 C 和 Objective-C 中,通常的做法是将一个布尔值选项集合表示为一系列值为 2 的整数次幂的枚举成员。

Swift 使用结构体(struct)来遵从 OptionSet 协议,以引入选项集合,而非枚举(enum)。为什么这样处理呢?当枚举成员互斥的时候,比如说,一次只有一个选项可以被选择的情况下,枚举是非常好的。但是和 C 不同,在 Swift 中,你无法把多个枚举成员组合成一个值,而 C 中的枚举对编译器来说就是整型,可以接受任意整数值。 

和 C 中一样,Swift 中的选项集合结构体使用了高效的位域来表示,但是这个结构体本身表现为一个集合,它的成员则为被选择的选项。这允许你使用标准的集合运算#Basic_operations)来维护位域,比如使用 contains 来检验集合中是否有某个成员,或者是用 union 来组合两个位域。另外,由于 OptionSet 继承于 ExpressibleByArrayLiteral,你可以使用数组字面量来生成一个选项集合。

如何创建你自己的选项集合类型呢?仅有的要求是,一个类型为整型的原始值(rawValue)和一个初始化构造器。对于结构体来说,Swift 通常都会自动提供一个逐一成员构造器(memberwise initializer),所以你并不需要自己写一个。rawValue 是位域底层的存储单元。每个选项都应该是静态的常量,并使用适当的值初始化了其位域。 

```swift
struct EWSLearningRemindDateOption: OptionSet {
    
    let rawValue: Int
    
    static let None = EWSLearningRemindDateOption(rawValue: 0)
    static let Sunday = EWSLearningRemindDateOption(rawValue: 1 << 0)
    static let Monday = EWSLearningRemindDateOption(rawValue: 1 << 1)
    static let Tuesday = EWSLearningRemindDateOption(rawValue: 1 << 2)
    static let Wednesday = EWSLearningRemindDateOption(rawValue: 1 << 3)
    static let Thursday = EWSLearningRemindDateOption(rawValue: 1 << 4)
    static let Friday = EWSLearningRemindDateOption(rawValue: 1 << 5)
    static let Saturday = EWSLearningRemindDateOption(rawValue: 1 << 6)
    
}
```

> 选项集合并不是集合类型 
> 
> 遵从 OptionSet 并不意味着遵从 Sequence 和 Collection 协议,所以你无法使用 count 来确定集合中有几个元素,也无法使用 for 循环来遍历选择的选项。从根本上说,一个选项集合仅仅是简单的整数值。

## 类和结构体
## 属性

属性可以将值与特定的类、结构体或者是枚举联系起来。存储属性会存储常量或变量作为实例的一部分，反之计算属性会计算（而不是存储）值。计算属性可以由类、结构体和枚举定义。存储属性只能由类和结构体定义。

存储属性和计算属性通常和特定类型的实例相关联（**实例属性**）。属性也可以与类型本身相关联，这种属性就是所谓的**类型属性**。

另外，你也可以定义属性观察器来检查属性中值的变化，这样你就可以用自定义的行为来响应。属性观察器可以被添加到你自己定义的存储属性中，也可以添加到子类从他的父类那里所继承来的属性中。

### 1. 存储属性

在其最简单的形式下，存储属性是一个作为特定类和结构体实例一部分的常量或变量。存储属性要么是变量存储属性（由 `var`  关键字引入）要么是常量存储属性（由 `let`  关键字引入）。

正如[默认属性值](#default_value)中所述，你可以为存储属性提供一个默认值作为它定义的一部分。你也可以在初始化的过程中设置和修改存储属性的初始值。正如在[初始化中分配常量属性](#init_value)所述，这一点对于常量存储属性也成立。

下面的例子定义了一个名为 FixedLengthRange 的结构体，它描述了一个一旦被创建长度就不能改变的整型值域：

```swift
struct FixedLengthRange {
    var firstValue: Int
    let length: Int
}
var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)
// the range represents integer values 0, 1, and 2
rangeOfThreeItems.firstValue = 6
// the range now represents integer values 6, 7, and 8
```

`FixedLengthRange` 的实例有一个名为 `firstValue` 的变量存储属性和一个名为 `length` 的常量存储属性。在上面的例子中，当新的值域创建时 `length` 已经被创建并且不能再修改，因为这是一个常量属性。

<p id = "const_struct_property"></p>
#### 1.1 常量结构体实例的存储属性

如果你创建了一个结构体的实例并且把这个实例赋给常量，你不能修改这个实例的属性，即使是声明为变量的属性：

```swift
let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)
// this range represents integer values 0, 1, 2, and 3
rangeOfFourItems.firstValue = 6
// * this will report an error, even though firstValue is a variable property
```

由于 `rangeOfFourItems` 被声明为常量（用 `let` 关键字），我们不能改变其 `firstValue` 属性，即使 `firstValue` 是一个变量属性。

这是由于结构体是`值类型`。当一个值类型的实例被标记为常量时，该实例的其他属性也均为常量。

对于类来说则不同，它是`引用类型`。如果你给一个常量赋值引用类型实例，你仍然可以修改那个实例的变量属性。

#### 1.2 延迟存储属性

延迟存储属性的初始值在其第一次使用时才进行计算。你可以通过在其声明前标注 `lazy` 修饰语来表示一个延迟存储属性。

> 你必须把延迟存储属性声明为变量（使用 `var` 关键字），因为它的初始值可能在实例初始化完成之前无法取得。常量属性则必须在初始化完成之前有值，因此不能声明为延迟。

一个属性的初始值可能依赖于某些外部因素，当这些外部因素的值只有在实例的初始化完成后才能得到时，延迟属性就可以发挥作用了。而当属性的初始值需要执行复杂或代价高昂的配置才能获得，你又想要在需要时才执行，延迟属性就能够派上用场了。

下面这个栗子使用了一个延迟存储属性来避免复杂类不必要的初始化。这个例子定义了两个名为 DartImporter 和 DartManager 的类，他们都没有完整显示：

```swift
class DataImporter {
    
    //DataImporter is a class to import data from an external file.
    //The class is assumed to take a non-trivial amount of time to initialize.
    
    var fileName = "data.txt"
    // the DataImporter class would provide data importing functionality here
}
 
class DataManager {
    lazy var importer = DataImporter()
    var data = [String]()
    // the DataManager class would provide data management functionality here
}
 
let manager = DataManager()
manager.data.append("Some data")
manager.data.append("Some more data")
// the DataImporter instance for the importer property has not yet been created
```

类 DataManager 有一个名为 data 的存储属性，它被初始化为一个空的新 String 数组。尽管它的其余功能没有展示出来，还是可以知道类 DataManager 的目的是管理并提供访问这个 String 数组的方法。

DataManager 类的功能之一是从文件导入数据。此功能由 DataImporter 类提供，它假定为需要一定时间来进行初始化。这大概是因为 DataImporter 实例在进行初始化的时候需要打开文件并读取其内容到内存中。

DataManager 实例并不要从文件导入数据就可以管理其数据的情况是有可能发生的，所以当 DataManager 本身创建的时候没有必要去再创建一个新的 DataImporter 实例。反之，在 DataImporter 第一次被使用的时候再创建它才更有意义。

因为它被 lazy 修饰符所标记，只有在 importer 属性第一次被访问时才会创建 DataManager 实例，比如当查询它的 fileName 属性时：

```swift
print(manager.importer.fileName)
// the DataImporter instance for the importer property has now been created
// prints "data.txt"
```

> 如果被标记为 lazy 修饰符的属性同时被多个线程访问并且属性还没有被初始化，则无法保证属性只初始化一次。

#### 1.3 存储属性与实例变量

如果你有 Objective-C 的开发经验，那你应该知道在类实例里有两种方法来存储值和引用。另外，你还可以使用实例变量作为属性中所储存的值的备份存储。

Swift 把这些概念都统一到了属性声明里。Swift 属性没有与之相对应的实例变量，并且属性的后备存储不能被直接访问。这避免了不同环境中对值的访问的混淆并且将属性的声明简化为一条单一的、限定的语句。所有关于属性的信息——包括它的名字，类型和内存管理特征——都作为类的定义放在了同一个地方。

### 2. 计算属性

除了存储属性，类、结构体和枚举也能够定义计算属性，而它实际并不存储值。相反，他们提供一个`读取器`和一个`可选的设置器`来间接得到和设置其他的属性和值。

```swift
struct Point {
    var x = 0.0, y = 0.0
}
struct Size {
    var width = 0.0, height = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
    var center: Point {
        get {
            let centerX = origin.x + (size.width / 2)
            let centerY = origin.y + (size.height / 2)
            return Point(x: centerX, y: centerY)
        }
        set(newCenter) {
            origin.x = newCenter.x - (size.width / 2)
            origin.y = newCenter.y - (size.height / 2)
        }
    }
}
var square = Rect(origin: Point(x: 0.0, y: 0.0),
    size: Size(width: 10.0, height: 10.0))
let initialSquareCenter = square.center
square.center = Point(x: 15.0, y: 15.0)
print("square.origin is now at (\(square.origin.x), \(square.origin.y))")
// prints "square.origin is now at (10.0, 10.0)"
```

#### 2.1 简写设置器（setter）声明

如果一个计算属性的设置器没有为将要被设置的值定义一个名字，那么他将被默认命名为 `newValue` 。下面是结构体 Rect 的另一种写法，其中利用了简写设置器声明的特性。

```swift
struct AlternativeRect {
    var origin = Point()
    var size = Size()
    var center: Point {
        get {
            let centerX = origin.x + (size.width / 2)
            let centerY = origin.y + (size.height / 2)
            return Point(x: centerX, y: centerY)
        }
        set {
            origin.x = newValue.x - (size.width / 2)
            origin.y = newValue.y - (size.height / 2)
        }
    }
}
```

#### 2.2 只读计算属性

一个有读取器但是没有设置器的计算属性就是所谓的只读计算属性。只读计算属性返回一个值，也可以通过点语法访问，但是不能被修改为另一个值。

> 你必须用 `var` 关键字定义计算属性——包括只读计算属性——为变量属性，因为它们的值不是固定的。 `let` 关键字只用于常量属性，用于明确那些值一旦作为实例初始化就不能更改。

你可以通过去掉 get 关键字和他的大扩号来简化只读计算属性的声明：

```swift
struct Cuboid {
    var width = 0.0, height = 0.0, depth = 0.0
    var volume: Double {
        return width * height * depth
    }
}
let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)
print("the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)")
// prints "the volume of fourByFiveByTwo is 40.0"
```

这个例子定义了一个名为 Cuboid 的新结构体，它代表了一个有 width ， height 和 depth 属性的三维长方形结构。这个结构体还有一个名为 volume 的只读计算属性，它计算并返回长方体的当前体积。对于 volume 属性来说可被设置并没有意义，因为它会明确 width ， height 和 depth 中哪个值用在特定的 volume 值中，对 Cuboid 来说提供一个只读计算属性来让外部用户来发现它的当前计算体积就显得很有用了。

### 3. 属性观察者

属性观察者会观察并对属性值的变化做出回应。每当一个属性的值被设置时，属性观察者都会被调用，即使这个值与该属性当前的值相同。

你可以为你定义的任意**存储属性**添加属性观察者，除了**延迟存储属性**。你也可以通过在子类里重写属性来为任何继承属性（无论是存储属性还是计算属性）添加属性观察者。属性重载将会在[重写](#rewrite)中详细描述。

> 你不需要为非重写的计算属性定义属性观察者，因为你可以在计算属性的设置器里直接观察和相应它们值的改变。

你可以选择将这些观察者或其中之一定义在属性上：

* `willSet` 会在该值被存储之前被调用。
* `didSet` 会在一个新值被存储后被调用。

如果你实现了一个 `willSet` 观察者，新的属性值会以常量形式参数传递。你可以在你的 `willSet` 实现中为这个参数定义名字。如果你没有为它命名，那么它会使用默认的名字 `newValue` 。

同样，如果你实现了一个 `didSet` 观察者，一个包含旧属性值的常量形式参数将会被传递。你可以为它命名，也可以使用默认的形式参数名 `oldValue` 。如果你在属性自己的 `didSet` 观察者里给自己赋值，你赋值的新值就会取代刚刚设置的值。

> 父类属性的 `willSet` 和 `didSet` 观察者会在子类初始化器中设置时被调用。它们不会在类的父类初始化器调用中设置其自身属性时被调用。

这里有一个关于 `willSet` 和 `didSet` 的使用栗子。下面的栗子定义了一个名为 StepCounter 的新类，它追踪人散步的总数量。这个类可能会用于从计步器或者其他计步工具导入数据来追踪人日常的锻炼情况。

```swift
class StepCounter {
    var totalSteps: Int = 0 {
        willSet(newTotalSteps) {
            print("About to set totalSteps to \(newTotalSteps)")
        }
        didSet {
            if totalSteps > oldValue  {
                print("Added \(totalSteps - oldValue) steps")
            }
        }
    }
}
let stepCounter = StepCounter()
stepCounter.totalSteps = 200
// About to set totalSteps to 200
// Added 200 steps
stepCounter.totalSteps = 360
// About to set totalSteps to 360
// Added 160 steps
stepCounter.totalSteps = 896
// About to set totalSteps to 896
// Added 536 steps
```

StepCounter 类声明了一个 Int 类型的 totalSteps 属性。这是一个包含了 willSet 和 didSet 观察者的储存属性。
totalSteps 的 willSet 和 didSet 观察者会在每次属性被赋新值的时候调用。就算新值与当前值完全相同也会如此。

栗子中的 willSet 观察者为增量的新值使用自定义的形式参数名 newTotalSteps ，它只是简单的打印出将要设置的值。

didSet 观察者在 totalSteps 的值更新后调用。它用旧值对比 totalSteps 的新值。如果总步数增加了，就打印一条信息来表示接收了多少新的步数。 didSet 观察者不会提供自定义的形式参数名给旧值，而是使用 oldValue 这个默认的名字。

> 如果你以输入输出形式参数传一个拥有观察者的属性给函数， willSet 和 didSet 观察者一定会被调用。这是由于输入输出形式参数的拷贝入拷贝出存储模型导致的：值一定会在函数结束后写回属性。


### 4. 全局和局部变量

上边描述的计算属性和观察属性的能力同样对全局变量和局部变量有效。全局变量是定义在任何函数、方法、闭包或者类型环境之外的变量。局部变量是定义在函数、方法或者闭包环境之中的变量。

你在之前章节中所遇到的全局和局部变量都是存储变量。存储变量，类似于存储属性，为特定类型的值提供存储并且允许这个值被设置和取回。

总之，你同样可以定义计算属性以及给存储变量定义观察者，无论是全局还是局部环境。计算变量计算而不是存储值，并且与计算属性的写法一致。

> 全局常量和变量永远是延迟计算的，与延迟存储属性有着相同的行为。不同于延迟存储属性，全局常量和变量不需要标记 `lazy` 修饰符。

### 5. 类型属性

实例属性是属于特定类型实例的属性。每次你创建这个类型的新实例，它就拥有一堆属性值，与其他实例不同。

你同样可以定义属于类型本身的属性，不是这个类型的某一个实例的属性。这个属性只有一个拷贝，无论你创建了多少个类对应的实例。这样的属性叫做类型属性。

类型属性在定义那些对特定类型的所有实例都通用的值的时候很有用，比如实例要使用的常量属性（类似 C 里的静态常量），或者储存对这个类型的所有实例全局可见的值的存储属性（类似 C 里的静态变量）。

存储类型属性可以是变量或者常量。计算类型属性总要被声明为变量属性，与计算实例属性一致。

> 不同于存储实例属性，你必须总是给存储类型属性一个默认值。这是因为类型本身不能拥有能够在初始化时给存储类型属性赋值的初始化器。
> 
> 存储类型属性是在它们第一次访问时延迟初始化的。它们保证只会初始化一次，就算被多个线程同时访问，他们也不需要使用 lazy 修饰符标记。

#### 5.1 类型属性语法

在 C 和  Objective-C 中，你使用全局静态变量来定义一个与类型关联的静态常量和变量。在 Swift 中，总之，类型属性是写在类型的定义之中的，在类型的花括号里，并且每一个类型属性都显式地放在它支持的类型范围内。

使用 `static` 关键字来开一类型属性。对于类类型的计算类型属性，你可以使用 `class` 关键字来允许子类重写父类的实现。下面的栗子展示了存储和计算类型属性的语法：

```swift 
struct SomeStructure {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
        return 1
    }
}
enum SomeEnumeration {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
        return 6
    }
}
class SomeClass {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
        return 27
    }
    class var overrideableComputedTypeProperty: Int {
        return 107
    }
}
```

#### 5.2 查询和设置类型属性

类型属性使用点语法来查询和设置，与类型属性一致。总之，类型属性在类里查询和设置，而不是这个类型的实例。举例来说：

```swift
print(SomeStructure.storedTypeProperty)
// prints "Some value."
SomeStructure.storedTypeProperty = "Another value."
print(SomeStructure.storedTypeProperty)
// prints "Another value."
print(SomeEnumeration.computedTypeProperty)
// prints "6"
print(SomeClass.computedTypeProperty)
// prints "27"
```

## 方法

### 1 实例方法
#### 1.1 self 属性

<p id = "change_value"></p>
#### 1.2 在实例方法中修改值类型

结构体和枚举是值类型。默认情况下，**值类型属性不能被自身的实例方法修改**。

总之，如果你需要在特定的方法中修改结构体或者枚举的属性，你可以选择将这个方法异变。然后这个方法就可以在方法中异变（嗯，改变）它的属性了，并且任何改变在方法结束的时候都会写入到原始的结构体中。方法同样可以指定一个全新的实例给它隐含的self属性，并且这个新的实例将会在方法结束的时候替换掉现存的这个实例。

你可以选择在 `func`关键字前放一个 `mutating`关键字来使用这个行为：

```swift
struct Point {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        x += deltaX
        y += deltaY
    }
}
var somePoint = Point(x: 1.0, y: 1.0)
somePoint.moveBy(x: 2.0, y: 3.0)
print("The point is now at (\(somePoint.x), \(somePoint.y))")
// prints "The point is now at (3.0, 4.0)"
```

上文中的 Point 结构体定义了一个异变方法 moveBy(x:y:)，它以特定的数值移动一个 Point实例。相比于返回一个新的点，这个方法实际上修改了调用它的点。 被添加到定义中的 mutating关键字允许它修改自身的属性。

注意，如同[常量结构体实例的存储属性](#const_struct_property)里描述的那样，你不能在常量结构体类型里调用异变方法，因为自身属性不能被改变，就算它们是变量属性：

```swift
let fixedPoint = Point(x: 3.0, y: 3.0)
fixedPoint.moveBy(x: 2.0, y: 3.0)
// this will report an error
```

#### 1.3 在异变方法里指定自身
### 2 类型方法

## 下标
## 继承

<p id = "rewrite"></p>
### 3.重写

子类可以提供它自己的实例方法、类型方法、实例属性，类型属性或下标脚本的自定义实现，否则它将会从父类继承。这就所谓的重写。

要重写而不是继承一个特征，你需要在你的重写定义前面加上 override 关键字。这样做说明你打算提供一个重写而不是意外提供了一个相同定义。意外的重写可能导致意想不到的行为，并且任何没有使用 override 关键字的重写都会在编译时被诊断为错误。

override 关键字会执行 Swift 编译器检查你重写的类的父类(或者父类的父类)是否有与之匹配的声明来供你重写。这个检查确保你重写的定义是正确的。
## 初始化

<p id = "default_value"></p>
### 默认的属性值

如上所述，你可以在初始化器里为存储属性设置初始值。另外，指定一个默认属性值作为属性声明的一部分。当属性被定义的时候你可以通过为这个属性分配一个初始值来指定默认的属性值。

> 如果一个属性一直保持相同的初始值，可以提供一个默认值而不是在初始化器里设置这个值。最终结果是一样的，但是默认值将属性的初始化与声明更紧密地联系到一起。它使得你的初始化器更短更清晰，并且可以让你属性根据默认值推断类型。如后边的章节所述，默认值也让你使用默认初始化器和初始化器继承更加容易。

通过提供 `temperature` 属性的默认值，你可以把上面的 `Fahrenheit` 结构体写的更简单：

```swift
struct Fahrenheit {
    var temperature = 32.0
}
```

<p id = "init_value"></p>
### 在初始化中分配常量属性

在初始化的任意时刻，你都可以给常量属性赋值，只要它在初始化结束时设置了确定的值即可。一旦为常量属性被赋值，它就不能再被修改了。

> 对于类实例来说，常量属性在初始化中只能通过引用的类来修改。它不能被子类修改。

你可以修改上面 `SurveyQuestion` 的例子，给 `text` 使用常量属性而不是变量属性来表示问题，来明确一旦 `SurveyQuestion` 的实例被创建，那个问题将不会改变。尽管现在 `text` 属性是一个常量，但是它依然可以在类的初始化器里设置：

```swift
class SurveyQuestion {
    let text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}
let beetsQuestion = SurveyQuestion(text: "How about beets?")
beetsQuestion.ask()
// prints "How about beets?"
beetsQuestion.response = "I also like beets. (But not with cheese.)"
```

## 反初始化
## 自动引用计数
## 可选链
## 错误处理
## 类型转换
## 内嵌类型
## 扩展

扩展为现有的类、结构体、枚举类型、或协议添加了新功能。这也包括了为无访问权限的源代码扩展类型的能力（即所谓的逆向建模）。扩展和 Objective-C 中的分类类似。（与 Objective-C 的分类不同的是，Swift 的扩展没有名字。）

Swift 中的扩展可以：

* 添加计算实例属性和计算类型属性；
* 定义实例方法和类型方法；
* 提供新初始化器；
* 定义下标；
* 定义和使用新内嵌类型；
* 使现有的类型遵循某协议

在 Swift 中，你甚至可以扩展一个协议，以提供其要求的实现或添加符合类型的附加功能。

> 扩展可以向一个类型添加新的方法，但是不能重写已有的方法。

### 1 扩展的语法

使用 `extension` 关键字来声明扩展：

```swift
extension SomeType {
    // new functionality to add to SomeType goes here
}
```

扩展可以使已有的类型遵循一个或多个协议。在这种情况下，协议名的书写方式与类或结构体完全一样：

```swift
extension SomeType: SomeProtocol, AnotherProtocol {
    // implementation of protocol requirements goes here
}
```

用这种方式添加协议一致性详见在扩展里添加协议遵循。

如同扩展一个泛型类型中描述的那样，扩展可以用于丰富现有泛型类型。如同带有泛型 Where 分句的扩展中描述的那样，你也可以可选地给泛型添加功能。

> 如果你向已存在的类型添加新功能，新功能会在该类型的所有实例中可用，即使实例在该扩展定义之前就已经创建。

### 2 计算属性

扩展可以向已有的类型添加计算实例属性和计算类型属性。下面的例子向 Swift 内建的 Double 类型添加了五个计算实例属性，以提供对距离单位的基本支持：

```swift
extension Double {
    var km: Double { return self * 1_000.0 }
    var m: Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
let oneInch = 25.4.mm
print("One inch is \(oneInch) meters")
// Prints "One inch is 0.0254 meters"
let threeFeet = 3.ft
print("Three feet is \(threeFeet) meters")
// Prints "Three feet is 0.914399970739201 meters"
```

这些计算属性表述了 Double 值应被看作是确定的长度单位。尽管它们被实现为计算属性，这些属性的名字仍可使用点符号添加在浮点型的字面量之后，作为一种使用该字面量来执行距离转换的方法。

在这个例子中，一个 1.0 的 Double 值表示“一米”。这就是为什么 m 计算属性要返回 self ——表达式 1.m 表示计算 1.0 的 Double 值。

其他的单位则在以米作为计量值的基础上加以转换表示。一千米表示1000米，所以 km 计算属性将值乘 1_000.00 以用米来表示。类似的，一米有3.28084英尺，所以 ft 计算属性用 Double 值除以3.28084，将英尺转换为米。

上述属性为只读计算属性，为了简洁没有使用 get 关键字。他们都返回 Double 类型的值，可用于所有使用 Double 值的数学计算中：

```swift
let aMarathon = 42.km + 195.m
print("A marathon is \(aMarathon) meters long")
// Prints "A marathon is 42195.0 meters long"
```

> 扩展可以添加新的计算属性，但是不能添加存储属性，也不能向已有的属性添加属性观察者。

### 3 初始化器

扩展可向已有的类型添加新的初始化器。这允许你扩展其他类型以使初始化器接收你的自定义类型作为形式参数，或提供该类型的原始实现中未包含的额外初始化选项。

扩展能为类添加新的**便捷初始化器**，但是不能为类添加**指定初始化器或反初始化器**。指定初始化器和反初始化器 必须由原来类的实现提供。

> 如果你使用扩展为一个值类型添加初始化器，且该值类型为其所有储存的属性提供默认值，而又不定义任何自定义初始化器时，你可以在你扩展的初始化器中调用该类型默认的初始化器和成员初始化器。

下面的例子定义了一个自定义的 Rect 结构体用于描述几何矩形。这个例子也定义了两个辅助结构体 Size 和 Point ，二者的默认值都是 0.0 ：

```swift
struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
}
```

如同默认初始化器中描述的那样，由于 Rect 结构体为其所有属性提供了默认值，它将自动接收一个默认的初始化器和一个成员初始化器。这些初始化器能用于创建新的 Rect 实例：

```swift
let defaultRect = Rect()
let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),
                          size: Size(width: 5.0, height: 5.0))
```

你可以扩展 Rect 结构体以额外提供一个接收特定原点和大小的初始化器：

```swift
extension Rect {
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
```

这个初始化器首先基于提供的 center 点和 size 值计算合适的原点。然后初始化器调用该结构体的自动成员初始化器 `init(origin:size:) `，这样就将新的原点和大小值保存在了对应属性中：

```swift
let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
                      size: Size(width: 3.0, height: 3.0))
// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)
```

> 如果你使用扩展提供了一个新的初始化器，你仍应确保每一个实例都在初始化完成时完全初始化。

### 4 方法

扩展可以为已有的类型添加新的实例方法和类型方法。下面的例子为 Int 类型添加了一个名为 repetitions 的新实例方法：

```swift
extension Int {
    func repetitions(task: () -> Void) {
        for _ in 0..<self {
            task()
        }
    }
}
```

`repetitions(task:)` 方法接收一个 `() -> Void` 类型的单一实际参数，它表示一个没有参数且无返回值的函数。

在这个扩展定义之后，你可以在任何整型数字处调用 `repetitions(task:)` 方法，以执行相应次数的操作：

```swift
3.repetitions {
    print("Hello!")
}
// Hello!
// Hello!
// Hello!
```

#### 4.1 异变实例方法

增加了扩展的实例方法仍可以修改（或异变）实例本身。结构体和枚举类型方法在修改 self 或本身的属性时必须标记实例方法为 mutating ，和原本实现的异变方法一样。

下面的例子为 Swift 的 Int 类型添加了一个新的异变方法 square ，以表示原值的平方：

```swift
extension Int {
    mutating func square() {
        self = self * self
    }
}
var someInt = 3
someInt.square()
// someInt is now 9
```

### 5 下标

扩展能为已有的类型添加新的下标。下面的例子为 Swift 内建的 Int 类型添加了一个整型下标。这个下标 [n] 返回了从右开始第 n 位的十进制数字：

* 123456789[0] 返回 9
* 123456789[1] 返回 8

……以此类推：

```swift
extension Int {
    subscript(digitIndex: Int) -> Int {
        var decimalBase = 1
        for _ in 0..<digitIndex {
            decimalBase *= 10
        }
        return (self / decimalBase) % 10
    }
}
746381295[0]
// returns 5
746381295[1]
// returns 9
746381295[2]
// returns 2
746381295[8]
// returns 7
```

### 6 内嵌类型

扩展可以为已有的类、结构体和枚举类型添加新的内嵌类型：

```swift
extension Int {
    enum Kind {
        case negative, zero, positive
    }
    var kind: Kind {
        switch self {
        case 0:
            return .zero
        case let x where x > 0:
            return .positive
        default:
            return .negative
        }
    }
}
```

这个例子为 Int 添加了新的内嵌枚举类型。这个名为 Kind 的枚举类型表示一个特定整数的类型。具体表示了这个数字是负数、零还是正数。

这个例还向 Int 中添加了新的计算实例属性 kind ，以返回该整数的合适 Kind 枚举情况。

这个内嵌的枚举类型可以和任意 Int 一起使用：

```swift
func printIntegerKinds(_ numbers: [Int]) {
    for number in numbers {
        switch number.kind {
        case .negative:
            print("- ", terminator: "")
        case .zero:
            print("0 ", terminator: "")
        case .positive:
            print("+ ", terminator: "")
        }
    }
    print("")
}
printIntegerKinds([3, 19, -27, 0, -6, 0, 7])
// Prints "+ + - 0 - 0 + "
```

这里 printIntegerKinds(_:) 函数接收一个 Int 的数组并对这些值进行遍历。对数组的每一个数字，函数考虑这个整数的 kind 计算属性，并输出合适的描述。

## 协议

协议为方法、属性、以及其他特定的任务需求或功能定义蓝图。协议可被类、结构体、或枚举类型采纳以提供所需功能的具体实现。满足了协议中需求的任意类型都叫做遵循了该协议。

除了指定遵循类型必须实现的要求外，你可以扩展一个协议以实现其中的一些需求或实现一个符合类型的可以利用的附加功能。

### 1 协议的语法

定义协议的方式与类、结构体、枚举类型非常相似：

```swift
protocol SomeProtocol {
    // protocol definition goes here
}
```

在自定义类型声明时，将协议名放在类型名的冒号之后来表示该类型采纳一个特定的协议。多个协议可以用逗号分开列出：

```swift
struct SomeStructure: FirstProtocol, AnotherProtocol {
    // structure definition goes here
}
```

若一个类拥有父类，将这个父类名放在其采纳的协议名之前，并用逗号分隔：

```swift
class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {
    // class definition goes here
}
```

### 2 属性要求

协议可以要求所有遵循该协议的类型提供特定名字和类型的实例属性或类型属性。协议并不会具体说明属性是储存型属性还是计算型属性——它只具体要求属性有特定的名称和类型。协议同时要求一个属性必须明确是`可读的`或`可读的和可写的`。

若协议要求一个属性为可读和可写的，那么该属性要求不能用常量存储属性或只读计算属性来满足。若协议只要求属性为可读的，那么任何种类的属性都能满足这个要求，而且如果你的代码需要的话，该属性也可以是可写的。

属性要求定义为变量属性，在名称前面使用 var 关键字。可读写的属性使用 { get set } 来写在声明后面来明确，使用 { get } 来明确可读的属性。

```swift 
protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}
```

在协议中定义类型属性时在前面添加 static 关键字。当类的实现使用 class 或 static 关键字前缀声明类型属性要求时，这个规则仍然适用：

```swift
protocol AnotherProtocol {
    static var someTypeProperty: Int { get set }
}
```

这里是一个只有一个实例属性要求的协议：

```swift
protocol FullyNamed {
    var fullName: String { get }
}
```

上面 FullyNamed 协议要求遵循的类型提供一个完全符合的名字。这个协议并未指定遵循类型的其他任何性质——它只要求这个属性必须为其自身提供一个全名。协议申明了所有 FullyNamed 类型必须有一个可读实例属性 fullName ，且为 String 类型。

这里是一个采纳并遵循 FullyNamed 协议的结构体的例子：

```swift
struct Person: FullyNamed {
    var fullName: String
}
var john = Person(fullName: "John Appleseed")
// john.fullName is "John Appleseed"
john.fullName = "John Bye!"
// john.fullName is "John Bye!"
```

这个例子定义了一个名为 Person 的结构体，它表示一个有名字的人。它在其第一行定义中表明了它采纳 FullyNamed 协议作为它自身的一部分。

每一个 Person 的实例都有一个名为 fullName 的 String 类型储存属性。这符合了 FullyNamed 协议的单一要求，并且表示 Person 已经正确地遵循了该协议。（若协议的要求没有完全达标，Swift 在编译时会报错。）

这里是一个更加复杂的类，采纳并遵循了 FullyNamed 协议：

```swift
class Starship: FullyNamed {
    var prefix: String?
    var name: String
    init(name: String, prefix: String? = nil) {
        self.name = name
        self.prefix = prefix
    }
    var fullName: String {
        return (prefix != nil ? prefix! + " " : "") + name
    }
}
var ncc1701 = Starship(name: "Enterprise", prefix: "USS")
// ncc1701.fullName is "USS Enterprise"
```

### 3 方法要求

协议可以要求采纳的类型实现指定的实例方法和类方法。这些方法作为协议定义的一部分，书写方式与正常实例和类方法的方式完全相同，但是不需要大括号和方法的主体。允许变量拥有参数，与正常的方法使用同样的规则。但在协议的定义中，方法参数不能定义默认值。

正如类型属性要求的那样，当协议中定义类型方法时，你总要在其之前添加 `static` 关键字。即使在类实现时，类型方法要求使用 `class` 或 `static` 作为关键字前缀，前面的规则仍然适用：

```swift
protocol SomeProtocol {
    static func someTypeMethod()
}
```

下面的例子定义了一个只有一个实例方法要求的协议：

```swift
protocol RandomNumberGenerator {
    func random() -> Double
}
```

这里 RandomNumberGenerator 协议要求所有采用该协议的类型都必须有一个实例方法 random ，而且要返回一个 Double 的值，无论这个值叫什么。尽管协议没有明确定义，这里默认这个值在 0.0  到 1.0 （不包括）之间。

RandomNumberGenerator 协议并不为随机值的生成过程做任何定义，它只要求生成器提供一个生成随机数的标准过程。

这里有一个采用并遵循 RandomNumberGenerator 协议的类的实现。这个类实现了著名的 linear congruential generator 伪随机数发生器算法：

```swift
class LinearCongruentialGenerator: RandomNumberGenerator {
    var lastRandom = 42.0
    let m = 139968.0
    let a = 3877.0
    let c = 29573.0
    func random() -> Double {
        lastRandom = ((lastRandom * a + c).truncatingRemainder(dividingBy:m))
        return lastRandom / m
    }
}
let generator = LinearCongruentialGenerator()
print("Here's a random number: \(generator.random())")
// Prints "Here's a random number: 0.37464991998171"
print("And another one: \(generator.random())")
// Prints "And another one: 0.729023776863283"
```

### 4 异变方法要求

有时一个方法需要改变（或异变）其所属的实例。例如值类型的实例方法（即结构体或枚举），在方法的 `func` 关键字之前使用 `mutating` 关键字，来表示在该方法可以改变其所属的实例，以及该实例的所有属性。这一过程写在了[在实例方法中修改值类型](#change_value)中。

若你定义了一个协议的实例方法需求，想要异变任何采用了该协议的类型实例，只需在协议里方法的定义当中使用 `mutating` 关键字。这允许结构体和枚举类型能采用相应协议并满足方法要求。

> 如果你在协议中标记实例方法需求为 `mutating` ，在为类实现该方法的时候不需要写 `mutating` 关键字。 `mutating` 关键字只在结构体和枚举类型中需要书写。

在Togglable协议的定义中， toggle() 方法使用 mutating 关键字标记，来表明该方法在调用时会改变遵循该协议的实例的状态：

```swift
protocol Togglable {
    mutating func toggle()
}
```

若使用结构体或枚举实现 Togglable 协议，这个结构体或枚举可以通过使用 mutating 标记这个 toggle() 方法，来保证该实现符合协议要求。

下面的例子定义了一个名为 OnOffSwitch 的枚举。这个枚举在两种状态间改变，即枚举成员 On 和 Off 。该枚举的 toggle 实现使用了 mutating 关键字，以满足 Togglable 协议需求：

```swift
enum OnOffSwitch: Togglable {
    case off, on
    mutating func toggle() {
        switch self {
        case .off:
            self = .on
        case .on:
            self = .off
        }
    }
}
var lightSwitch = OnOffSwitch.off
lightSwitch.toggle()
// lightSwitch is now equal to .on
```

### 5 初始化器要求	

协议可以要求遵循协议的类型实现指定的初始化器。和一般的初始化器一样，只用将初始化器写在协议的定义当中，只是不用写大括号也就是初始化器的实体：

```swift
protocol SomeProtocol {
    init(someParameter: Int)
}
```

#### 5.1 协议初始化器要求的类实现

你可以通过实现指定初始化器或便捷初始化器来使遵循该协议的类满足协议的初始化器要求。在这两种情况下，你都必须使用 `required` 关键字修饰初始化器的实现：

```swift
class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // initializer implementation goes here
    }
}
```

在遵循协议的类的所有子类中， `required` 修饰的使用保证了你为协议初始化器要求提供了一个明确的继承实现。

> 由于 `final` 的类不会有子类，如果协议初始化器实现的类使用了 `final` 标记，你就不需要使用 `required` 来修饰了。因为这样的类不能被继承子类。详见阻止重写了解更多 final 修饰符的信息。

如果一个子类重写了父类指定的初始化器，并且遵循协议实现了初始化器要求，那么就要为这个初始化器的实现添加 `required` 和 `override` 两个修饰符：

```swift
protocol SomeProtocol {
    init()
}
 
class SomeSuperClass {
    init() {
        // initializer implementation goes here
    }
}
 
class SomeSubClass: SomeSuperClass, SomeProtocol {
    // "required" from SomeProtocol conformance; "override" from SomeSuperClass
    required override init() {
        // initializer implementation goes here
    }
}
```

#### 5.2 可失败初始化器要求

如同可失败初始化器定义的一样，协议可以为遵循该协议的类型定义可失败的初始化器。

遵循协议的类型可以使用一个可失败的或不可失败的初始化器满足一个可失败的初始化器要求。不可失败初始化器要求可以使用一个不可失败初始化器或隐式展开的可失败初始化器满足。

### 6 将协议作为类型

实际上协议自身并不实现功能。不过你创建的任意协议都可以变为一个功能完备的类型在代码中使用。

由于它是一个类型，你可以在很多其他类型可以使用的地方使用协议，包括：

* 在函数、方法或者初始化器里作为形式参数类型或者返回类型；
* 作为常量、变量或者属性的类型；
* 作为数组、字典或者其他存储器的元素的类型。

> 由于协议是类型，要开头大写（比如说 FullyNamed 和 RandomNumberGenerator ）来匹配 Swift 里其他类型名称格式（比如说 Int 、 String 还有 Double ）。

这里有一个把协议用作类型的例子：

```swift
class Dice {
    let sides: Int
    let generator: RandomNumberGenerator
    init(sides: Int, generator: RandomNumberGenerator) {
        self.sides = sides
        self.generator = generator
    }
    func roll() -> Int {
        return Int(generator.random() * Double(sides)) + 1
    }
}
```

这个例子定义了一个叫做 Dice 的新类，它表示一个用于棋盘游戏的 n 面骰子。 Dice 实例有一个叫做 sides 的整数属性，它表示了骰子有多少个面，还有个叫做 generator 的属性，它提供了随机数的生成器来生成骰子的值。

generator 属性是 RandomNumberGenerator 类型。因此，你可以把它放到任何采纳了 RandomNumberGenerator 协议的类型的实例里。除了这个实例必须采纳 RandomNumberGenerator 协议以外，没有其他任何要求了。

Dice 也有一个初始化器，来设置初始状态。这个初始化器有一个形式参数叫做 generator ，它同样也是 RandomNumberGenerator 类型。你可以在初始化新的 Dice 实例的时候传入一个任意遵循这个协议的类型的值到这个形式参数里。

Dice 提供了一个形式参数方法， roll ，它返回一个介于 1 和骰子面数之间的整数值。这个方法调用生成器的 random() 方法来创建一个新的介于 0.0 和 1.0 之间的随机数，然后使用这个随机数来在正确的范围创建一个骰子的值。由于 generator 已知采纳了 RandomNumberGenerator ，它保证了会有 random() 方法以供调用。

这里是 Dice 类使用 LinearCongurentialGenerator 实例作为用于创建一个六面骰子的随机数生成器来创建一个六面骰子的过程：

```swift
var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())
for _ in 1...5 {
    print("Random dice roll is \(d6.roll())")
}
// Random dice roll is 3
// Random dice roll is 5
// Random dice roll is 4
// Random dice roll is 5
// Random dice roll is 4
```

### 7 委托

委托是一个允许类或者结构体放手（或者说委托）它们自身的某些责任给另外类型实例的设计模式。这个设计模式通过定义一个封装了委托责任的协议来实现，比如遵循了协议的类型（所谓的委托）来保证提供被委托的功能。委托可以用来响应一个特定的行为，或者从外部资源取回数据而不需要了解资源具体的类型。

下面的例子定义了两个协议以用于基于骰子的棋盘游戏：

```swift
protocol DiceGame {
    var dice: Dice { get }
    func play()
}
protocol DiceGameDelegate {
    func gameDidStart(_ game: DiceGame)
    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)
    func gameDidEnd(_ game: DiceGame)
}
```

DiceGame 协议是一个给任何与骰子有关的游戏采纳的协议。 DiceGameDelegate 协议可以被任何追踪 DiceGame 进度的类型采纳。

这里有一个原本在控制流中介绍的蛇与梯子游戏的一个版本。这个版本采纳了协议以使用 Dice 实例来让它使用骰子；采用 DiceGame 协议；然后通知一个 DiceGameDelegate 关于进度的信息：

```swift
class SnakesAndLadders: DiceGame {
    let finalSquare = 25
    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())
    var square = 0
    var board: [Int]
    init() {
        board = Array(repeating: 0, count: finalSquare + 1)
        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
    }
    var delegate: DiceGameDelegate?
    func play() {
        square = 0
        delegate?.gameDidStart(self)
        gameLoop: while square != finalSquare {
            let diceRoll = dice.roll()
            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)
            switch square + diceRoll {
            case finalSquare:
                break gameLoop
            case let newSquare where newSquare > finalSquare:
                continue gameLoop
            default:
                square += diceRoll
                square += board[square]
            }
        }
        delegate?.gameDidEnd(self)
    }
}
```

这个版本的游戏使用了叫做 SnakesAndLadders 类包装，它采纳了 DiceGame 协议。它提供了可读的 dice 属性和一个 play() 方法来遵循协议。（ dice 属性声明为常量属性是因为它不需要在初始化后再改变了，而且协议只需要它是可读的。）

蛇与梯子游戏棋盘设置都写在了类的 init() 初始化器中。所有的游戏逻辑都移动到了协议的 play 方法里，它使用了协议要求的 dice 属性来提供它的骰子值。

注意 delegate 属性被定义为可选的 DiceGameDelegate ，是因为玩游戏并不是必须要有委托。由于它是一个可选类型， delegate 属性自动地初始化为 nil 。此后，游戏的实例化者可以选择给属性赋值一个合适的委托。

DiceGameDelegate 提供了三个追踪游戏进度的方法。这三个方法在游戏逻辑的 play() 方法中协作，并且在游戏开始时调用，新一局开始，或者游戏结束。

由于 delegate 属性是可选的 DiceGameDelegate ， play() 方法在每次调用委托的时候都使用可选链。如果 delegate 属性是空的，这些委托调用会优雅地失败并且没有错误。如果 delegate 属性非空，委托的方法就被调用了，并且把 SnakesAndLadders 实例作为形式参数传入。

接下来的例子展示了叫做 DiceGameTracker 的类，它次那了 DiceGameDelegate 协议：

```swift
class DiceGameTracker: DiceGameDelegate {
    var numberOfTurns = 0
    func gameDidStart(_ game: DiceGame) {
        numberOfTurns = 0
        if game is SnakesAndLadders {
            print("Started a new game of Snakes and Ladders")
        }
        print("The game is using a \(game.dice.sides)-sided dice")
    }
    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {
        numberOfTurns += 1
        print("Rolled a \(diceRoll)")
    }
    func gameDidEnd(_ game: DiceGame) {
        print("The game lasted for \(numberOfTurns) turns")
    }
}
```

DiceGameTracker 实现了 DiceGameDelegate 要求的所有方法。它使用这些方法来对游戏开了多少局保持追踪。它在游戏开始的时候重置 numberOfTurns 属性为零，在每次新一轮游戏开始的时候增加，并且一旦游戏结束，打印出游戏一共开了多少轮。

上边展示的 `gameDidStart(_:) `的实现使用了 game 形式参数来打印某些关于游戏的信息。 game 形式参数是 DiceGame 类型，不是 SnakesAndLadders ，所以 `gameDidStart(_:)` 只能访问和使用 DiceGame 协议实现的那部分方法和属性。总之，转换类型之后方法还是可以使用的。在这个例子中，它检查 game 在后台是否就是 SnakesAndLadders 实例，如果是，打印合适的信息。

`gameDidStart(_:)` 方法同样访问传入的 game 形式参数里的 dice 属性。由于 game 已经遵循 DiceGame 协议，这就保证了dice属性的存在，并且 `gameDidStart(_:)`方法能够访问和打印骰子的 sides 属性，无论玩的是什么类型的游戏。

这里是 DiceGameTracker 的运行结果：

```swift
let tracker = DiceGameTracker()
let game = SnakesAndLadders()
game.delegate = tracker
game.play()
// Started a new game of Snakes and Ladders
// The game is using a 6-sided dice
// Rolled a 3
// Rolled a 5
// Rolled a 4
// Rolled a 5
// The game lasted for 4 turns
```

### 8 在扩展里添加协议遵循
#### 8.1 使用扩展声明采纳协议
### 9 协议类型的集合
### 10 协议继承
### 11 类专用的协议
### 12 协议组合
### 13 协议遵循的检查
### 14 可选协议要求
### 15 协议扩展
#### 15.1 提供默认实现
#### 15.2 给协议扩展添加限制


## 泛型
## 内存安全性
## 访问控制

`访问控制`限制其他源文件和模块对你的代码的访问。这个特性允许你隐藏代码的实现细节，并指定一个偏好的接口让其他代码可以访问和使用。

你可以给特定的单个类型 (类，结构体和枚举)设置访问级别，比如说属性、方法、初始化器以及属于那些类型的下标。协议可以限制在一定的范围内使用，就像全局常量，变量，函数那样。

除了提供各种级别的访问控制，Swift 为典型场景提供默认的访问级别，减少了显式指定访问控制级别的需求。 事实上，如果你编写单目标应用程序，你可能根本不需要显式指定访问控制级别。

### 1. 模块和源文件

Swift 的访问控制模型基于模块和源文件的概念。

`模块是单一的代码分配单元——一个框架或应用程序会作为的独立的单元构建和发布并且可以使用 Swift 的 import 关键字导入到另一个模块。`

Xcode 中的每个构建目标（例如应用程序包或框架）在 Swift 中被视为一个独立的模块。 如果你将应用程序的代码作为独立的框架组合在一起——或许可以在多个应用程序中封装和重用该代码——那么当在一个应用程序中导入和使用时，在该框架中定义的所有内容都将作为独立模块的一部分 ，或是当它在另一个框架中使用时。

`源文件是一个模块中的单个 Swift 源代码文件（实际上，是一个应用程序或是框架中的单个文件）。`虽然通常在单独源文件中定义单个类型，但是一个源文件可以包含多个类型。函数等的定义。

### 2. 访问级别

Swift 为代码的实体提供个五个不同的访问级别。这些访问级别和定义实体的源文件相关，并且也和源文件所属的模块相关。

> Open 访问 和 public 访问 允许实体被定义模块中的任意源文件访问，同样可以被另一模块的源文件通过导入该定义模块来访问。在指定框架的公共接口时，通常使用 open 或 public 访问。 open 访问仅适用于类和类成员，它与 public 访问区别如下：
> 
> > public 访问，或任何更严格的访问级别的类，只能在其定义模块中被继承。
> > 
> > public 访问，或任何更严格访问级别的类成员，只能被其定义模块的子类重写。
> > 
> > open 类可以在其定义模块中被继承，也可在任何导入定义模块的其他模块中被继承。
> > 
> > open 类成员可以被其定义模块的子类重写，也可以被导入其定义模块的任何模块重写。
> > 
> 
> Internal 访问 允许实体被定义模块中的任意源文件访问，但不能被该模块之外的任何源文件访问。通常在定义应用程序或是框架的内部结构时使用。
> 
> File-private 访问 将实体的使用限制于当前定义源文件中。当一些细节在整个文件中使用时，使用 file-private 访问隐藏特定功能的实现细节。
> 
> private 访问 将实体的使用限制于封闭声明中。当一些细节仅在单独的声明中使用时，使用 private 访问隐藏特定功能的实现细节。
> 
> open 访问是最高的（限制最少）访问级别，private 是最低的（限制最多）访问级别。

显式地标记类为 open 意味着你考虑过其他模块使用该类作为父类对代码的影响，并且相应地设计了类的代码。






## 高级运算符
